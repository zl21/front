/*
 * JQuery zTree exHideNodes v3.5.23
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2016-04-01
 */
// const jQuery = require('./jquery-1.4.4.min');

(function (i) { 
  i.extend(!0, i.fn.zTree._z, {
    view: {
      clearOldFirstNode(c, a) { for (let b = a.getNextNode(); b;) { if (b.isFirstNode) { b.isFirstNode = !1; d.setNodeLineIcos(c, b); break; } if (b.isLastNode) break; b = b.getNextNode(); } }, 
      clearOldLastNode(c, a, b) { for (a = a.getPreNode(); a;) { if (a.isLastNode) { a.isLastNode = !1; b && d.setNodeLineIcos(c, a); break; } if (a.isFirstNode) break; a = a.getPreNode(); } }, 
      makeDOMNodeMainBefore(c, a, b) {
        c.push('<li ', b.isHidden ? "style='display:none;' " : '', "id='", b.tId, "' class='", l.className.LEVEL,
          b.level, "' tabindex='0' hidefocus='true' treenode>"); 
      }, 
      showNode(c, a) { a.isHidden = !1; f.initShowForExCheck(c, a); j(a, c).show(); }, 
      showNodes(c, a, b) { if (a && a.length != 0) { const e = {}; let g; let k; for (g = 0, k = a.length; g < k; g++) { const h = a[g]; if (!e[h.parentTId]) { const i = h.getParentNode(); e[h.parentTId] = i === null ? f.getRoot(c) : h.getParentNode(); }d.showNode(c, h, b); } for (const j in e)a = e[j][c.data.key.children], d.setFirstNodeForShow(c, a), d.setLastNodeForShow(c, a); } }, 
      hideNode(c, a) {
        a.isHidden = !0; a.isFirstNode = !1; a.isLastNode = !1; f.initHideForExCheck(c, a); d.cancelPreSelectedNode(c, a); j(a, c).hide(); 
      }, 
      hideNodes(c, a, b) { if (a && a.length != 0) { const e = {}; let g; let k; for (g = 0, k = a.length; g < k; g++) { const h = a[g]; if ((h.isFirstNode || h.isLastNode) && !e[h.parentTId]) { const i = h.getParentNode(); e[h.parentTId] = i === null ? f.getRoot(c) : h.getParentNode(); }d.hideNode(c, h, b); } for (const j in e)a = e[j][c.data.key.children], d.setFirstNodeForHide(c, a), d.setLastNodeForHide(c, a); } }, 
      setFirstNode(c, a) {
        const b = c.data.key.children; const e = a[b].length; e > 0 && !a[b][0].isHidden
          ? a[b][0].isFirstNode = !0 : e > 0 && d.setFirstNodeForHide(c, a[b]); 
      }, 
      setLastNode(c, a) { const b = c.data.key.children; const e = a[b].length; e > 0 && !a[b][0].isHidden ? a[b][e - 1].isLastNode = !0 : e > 0 && d.setLastNodeForHide(c, a[b]); }, 
      setFirstNodeForHide(c, a) { let b; let e; let g; for (e = 0, g = a.length; e < g; e++) { b = a[e]; if (b.isFirstNode) break; if (!b.isHidden && !b.isFirstNode) { b.isFirstNode = !0; d.setNodeLineIcos(c, b); break; } else b = null; } return b; }, 
      setFirstNodeForShow(c, a) {
        let b; let e; let g; let f; let h; for (e = 0, g = a.length; e < g; e++) {
          if (b = a[e], !f && !b.isHidden
&& b.isFirstNode) { f = b; break; } else if (!f && !b.isHidden && !b.isFirstNode)b.isFirstNode = !0, f = b, d.setNodeLineIcos(c, b); else if (f && b.isFirstNode) { b.isFirstNode = !1; h = b; d.setNodeLineIcos(c, b); break; } 
        } return { new: f, old: h }; 
      }, 
      setLastNodeForHide(c, a) { let b; let e; for (e = a.length - 1; e >= 0; e--) { b = a[e]; if (b.isLastNode) break; if (!b.isHidden && !b.isLastNode) { b.isLastNode = !0; d.setNodeLineIcos(c, b); break; } else b = null; } return b; }, 
      setLastNodeForShow(c, a) {
        let b; let e; let g; let f; for (e = a.length - 1; e >= 0; e--) {
          if (b = a[e], !g && !b.isHidden
&& b.isLastNode) { g = b; break; } else if (!g && !b.isHidden && !b.isLastNode)b.isLastNode = !0, g = b, d.setNodeLineIcos(c, b); else if (g && b.isLastNode) { b.isLastNode = !1; f = b; d.setNodeLineIcos(c, b); break; } 
        } return { new: g, old: f }; 
      }
    }, 
    data: {
      initHideForExCheck(c, a) { if (a.isHidden && c.check && c.check.enable) { if (typeof a._nocheck === 'undefined')a._nocheck = !!a.nocheck, a.nocheck = !0; a.check_Child_State = -1; d.repairParentChkClassWithSelf && d.repairParentChkClassWithSelf(c, a); } }, 
      initShowForExCheck(c, a) {
        if (!a.isHidden && c.check
&& c.check.enable) { if (typeof a._nocheck !== 'undefined')a.nocheck = a._nocheck, delete a._nocheck; if (d.setChkClass) { const b = j(a, l.id.CHECK, c); d.setChkClass(c, b, a); }d.repairParentChkClassWithSelf && d.repairParentChkClassWithSelf(c, a); } 
      }
    }
  }); var i = i.fn.zTree; 
  const m = i._z.tools; 
  var l = i.consts; 
  var d = i._z.view; 
  var f = i._z.data; 
  var j = m.$; f.addInitNode((c, a, b) => { if (typeof b.isHidden === 'string')b.isHidden = m.eqs(b.isHidden, 'true'); b.isHidden = !!b.isHidden; f.initHideForExCheck(c, b); }); f.addBeforeA(() => {}); f.addZTreeTools((c, a) => {
    a.showNodes = function (a, b) { d.showNodes(c, a, b); }; a.showNode = function (a, b) { a && d.showNodes(c, [a], b); }; a.hideNodes = function (a, b) { d.hideNodes(c, a, b); }; a.hideNode = function (a, b) { a && d.hideNodes(c, [a], b); }; const b = a.checkNode; if (b)a.checkNode = function (c, d, f, h) { (!c || !c.isHidden) && b.apply(a, arguments); }; 
  }); const n = f.initNode; f.initNode = function (c, a, b, e, g, i, h) { 
    const j = (e || f.getRoot(c))[c.data.key.children]; f.tmpHideFirstNode = d.setFirstNodeForHide(c, j); f.tmpHideLastNode = d.setLastNodeForHide(c, j); h && (d.setNodeLineIcos(c, f.tmpHideFirstNode),
    d.setNodeLineIcos(c, f.tmpHideLastNode)); g = f.tmpHideFirstNode === b; i = f.tmpHideLastNode === b; n && n.apply(f, arguments); h && i && d.clearOldLastNode(c, b, h);
  }; const o = f.makeChkFlag; if (o)f.makeChkFlag = function (c, a) { (!a || !a.isHidden) && o.apply(f, arguments); }; const p = f.getTreeCheckedNodes; if (p)f.getTreeCheckedNodes = function (c, a, b, e) { if (a && a.length > 0) { const d = a[0].getParentNode(); if (d && d.isHidden) return []; } return p.apply(f, arguments); }; const q = f.getTreeChangeCheckedNodes; if (q) {
    f.getTreeChangeCheckedNodes = function (c, a, b) { 
      if (a
&& a.length > 0) { const d = a[0].getParentNode(); if (d && d.isHidden) return []; } return q.apply(f, arguments);
    }; 
  } const r = d.expandCollapseSonNode; if (r)d.expandCollapseSonNode = function (c, a, b, e, f) { (!a || !a.isHidden) && r.apply(d, arguments); }; const s = d.setSonNodeCheckBox; if (s)d.setSonNodeCheckBox = function (c, a, b, e) { (!a || !a.isHidden) && s.apply(d, arguments); }; const t = d.repairParentChkClassWithSelf; if (t)d.repairParentChkClassWithSelf = function (c, a) { (!a || !a.isHidden) && t.apply(d, arguments); };
}(jQuery));
