/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk$Bcl"] = self["webpackChunk$Bcl"] || []).push([["vendors-node_modules_vue-slicksort_dist_vue-slicksort_umd_js"],{

/***/ "./node_modules/vue-slicksort/dist/vue-slicksort.umd.js":
/*!**************************************************************!*\
  !*** ./node_modules/vue-slicksort/dist/vue-slicksort.umd.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("(function (global, factory) {\n\t true ? factory(exports) :\n\t0;\n}(this, (function (exports) { 'use strict';\n\n// Export Sortable Element Component Mixin\nvar ElementMixin = {\n  inject: ['manager'],\n  props: {\n    index: {\n      type: Number,\n      required: true\n    },\n    collection: {\n      type: [String, Number],\n      default: 'default'\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  mounted: function mounted() {\n    var _$props = this.$props,\n        collection = _$props.collection,\n        disabled = _$props.disabled,\n        index = _$props.index;\n\n\n    if (!disabled) {\n      this.setDraggable(collection, index);\n    }\n  },\n\n\n  watch: {\n    index: function index(newIndex) {\n      if (this.$el && this.$el.sortableInfo) {\n        this.$el.sortableInfo.index = newIndex;\n      }\n    },\n    disabled: function disabled(isDisabled) {\n      if (isDisabled) {\n        this.removeDraggable(this.collection);\n      } else {\n        this.setDraggable(this.collection, this.index);\n      }\n    },\n    collection: function collection(newCollection, oldCollection) {\n      this.removeDraggable(oldCollection);\n      this.setDraggable(newCollection, this.index);\n    }\n  },\n\n  beforeDestroy: function beforeDestroy() {\n    var collection = this.collection,\n        disabled = this.disabled;\n\n\n    if (!disabled) this.removeDraggable(collection);\n  },\n\n  methods: {\n    setDraggable: function setDraggable(collection, index) {\n      var node = this.$el;\n\n      node.sortableInfo = {\n        index: index,\n        collection: collection,\n        manager: this.manager\n      };\n\n      this.ref = { node: node };\n      this.manager.add(collection, this.ref);\n    },\n    removeDraggable: function removeDraggable(collection) {\n      this.manager.remove(collection, this.ref);\n    }\n  }\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\nvar Manager = function () {\n  function Manager() {\n    classCallCheck(this, Manager);\n\n    this.refs = {};\n  }\n\n  createClass(Manager, [{\n    key: \"add\",\n    value: function add(collection, ref) {\n      if (!this.refs[collection]) {\n        this.refs[collection] = [];\n      }\n\n      this.refs[collection].push(ref);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(collection, ref) {\n      var index = this.getIndex(collection, ref);\n\n      if (index !== -1) {\n        this.refs[collection].splice(index, 1);\n      }\n    }\n  }, {\n    key: \"isActive\",\n    value: function isActive() {\n      return this.active;\n    }\n  }, {\n    key: \"getActive\",\n    value: function getActive() {\n      var _this = this;\n\n      return this.refs[this.active.collection].find(function (_ref) {\n        var node = _ref.node;\n        return node.sortableInfo.index == _this.active.index;\n      });\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(collection, ref) {\n      return this.refs[collection].indexOf(ref);\n    }\n  }, {\n    key: \"getOrderedRefs\",\n    value: function getOrderedRefs() {\n      var collection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.active.collection;\n\n      return this.refs[collection].sort(function (a, b) {\n        return a.node.sortableInfo.index - b.node.sortableInfo.index;\n      });\n    }\n  }]);\n  return Manager;\n}();\n\nfunction arrayMove(arr, previousIndex, newIndex) {\n  var array = arr.slice(0);\n  if (newIndex >= array.length) {\n    var k = newIndex - array.length;\n    while (k-- + 1) {\n      array.push(undefined);\n    }\n  }\n  array.splice(newIndex, 0, array.splice(previousIndex, 1)[0]);\n  return array;\n}\n\nvar events = {\n  start: ['touchstart', 'mousedown'],\n  move: ['touchmove', 'mousemove'],\n  end: ['touchend', 'touchcancel', 'mouseup']\n};\n\nvar vendorPrefix = function () {\n  if (typeof window === 'undefined' || typeof document === 'undefined') return ''; // server environment\n  // fix for:\n  //    https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n  //    window.getComputedStyle() returns null inside an iframe with display: none\n  // in this case return an array with a fake mozilla style in it.\n  var styles = window.getComputedStyle(document.documentElement, '') || ['-moz-hidden-iframe'];\n  var pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1];\n\n  switch (pre) {\n    case 'ms':\n      return 'ms';\n    default:\n      return pre && pre.length ? pre[0].toUpperCase() + pre.substr(1) : '';\n  }\n}();\n\nfunction closest(el, fn) {\n  while (el) {\n    if (fn(el)) return el;\n    el = el.parentNode;\n  }\n}\n\nfunction limit(min, max, value) {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\nfunction getCSSPixelValue(stringValue) {\n  if (stringValue.substr(-2) === 'px') {\n    return parseFloat(stringValue);\n  }\n  return 0;\n}\n\nfunction getElementMargin(element) {\n  var style = window.getComputedStyle(element);\n\n  return {\n    top: getCSSPixelValue(style.marginTop),\n    right: getCSSPixelValue(style.marginRight),\n    bottom: getCSSPixelValue(style.marginBottom),\n    left: getCSSPixelValue(style.marginLeft)\n  };\n}\n\n// Export Sortable Container Component Mixin\nvar ContainerMixin = {\n  data: function data() {\n    return {\n      sorting: false,\n      sortingIndex: null,\n      manager: new Manager(),\n      events: {\n        start: this.handleStart,\n        move: this.handleMove,\n        end: this.handleEnd\n      }\n    };\n  },\n\n\n  props: {\n    value: { type: Array, required: true },\n    axis: { type: String, default: 'y' }, // 'x', 'y', 'xy'\n    distance: { type: Number, default: 0 },\n    pressDelay: { type: Number, default: 0 },\n    pressThreshold: { type: Number, default: 5 },\n    useDragHandle: { type: Boolean, default: false },\n    useWindowAsScrollContainer: { type: Boolean, default: false },\n    hideSortableGhost: { type: Boolean, default: true },\n    lockToContainerEdges: { type: Boolean, default: false },\n    lockOffset: { type: [String, Number, Array], default: '50%' },\n    transitionDuration: { type: Number, default: 300 },\n    appendTo: { type: String, default: 'body' },\n    draggedSettlingDuration: { type: Number, default: null },\n    lockAxis: String,\n    helperClass: String,\n    contentWindow: Object,\n    shouldCancelStart: {\n      type: Function,\n      default: function _default(e) {\n        // Cancel sorting if the event target is an `input`, `textarea`, `select` or `option`\n        var disabledElements = ['input', 'textarea', 'select', 'option', 'button'];\n        return disabledElements.indexOf(e.target.tagName.toLowerCase()) !== -1;\n      }\n    },\n    getHelperDimensions: {\n      type: Function,\n      default: function _default(_ref) {\n        var node = _ref.node;\n        return {\n          width: node.offsetWidth,\n          height: node.offsetHeight\n        };\n      }\n    }\n  },\n\n  provide: function provide() {\n    return {\n      manager: this.manager\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.container = this.$el;\n    this.document = this.container.ownerDocument || document;\n    this._window = this.contentWindow || window;\n    this.scrollContainer = this.useWindowAsScrollContainer ? this.document.body : this.container;\n\n    var _loop = function _loop(key) {\n      if (_this.events.hasOwnProperty(key)) {\n        events[key].forEach(function (eventName) {\n          return _this.container.addEventListener(eventName, _this.events[key], { passive: true });\n        });\n      }\n    };\n\n    for (var key in this.events) {\n      _loop(key);\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    var _this2 = this;\n\n    var _loop2 = function _loop2(key) {\n      if (_this2.events.hasOwnProperty(key)) {\n        events[key].forEach(function (eventName) {\n          return _this2.container.removeEventListener(eventName, _this2.events[key]);\n        });\n      }\n    };\n\n    for (var key in this.events) {\n      _loop2(key);\n    }\n  },\n\n\n  methods: {\n    handleStart: function handleStart(e) {\n      var _this3 = this;\n\n      var _$props = this.$props,\n          distance = _$props.distance,\n          shouldCancelStart = _$props.shouldCancelStart;\n\n\n      if (e.button === 2 || shouldCancelStart(e)) {\n        return false;\n      }\n\n      this._touched = true;\n      this._pos = this.getOffset(e);\n\n      var node = closest(e.target, function (el) {\n        return el.sortableInfo != null;\n      });\n\n      if (node && node.sortableInfo && this.nodeIsChild(node) && !this.sorting) {\n        var useDragHandle = this.$props.useDragHandle;\n        var _node$sortableInfo = node.sortableInfo,\n            index = _node$sortableInfo.index,\n            collection = _node$sortableInfo.collection;\n\n\n        if (useDragHandle && !closest(e.target, function (el) {\n          return el.sortableHandle != null;\n        })) return;\n\n        this.manager.active = { index: index, collection: collection };\n\n        /*\n        * Fixes a bug in Firefox where the :active state of anchor tags\n        * prevent subsequent 'mousemove' events from being fired\n        * (see https://github.com/clauderic/react-sortable-hoc/issues/118)\n        */\n        if (e.target.tagName.toLowerCase() === 'a') {\n          e.preventDefault();\n        }\n\n        if (!distance) {\n          if (this.$props.pressDelay === 0) {\n            this.handlePress(e);\n          } else {\n            this.pressTimer = setTimeout(function () {\n              return _this3.handlePress(e);\n            }, this.$props.pressDelay);\n          }\n        }\n      }\n    },\n    nodeIsChild: function nodeIsChild(node) {\n      return node.sortableInfo.manager === this.manager;\n    },\n    handleMove: function handleMove(e) {\n      var _$props2 = this.$props,\n          distance = _$props2.distance,\n          pressThreshold = _$props2.pressThreshold;\n\n\n      if (!this.sorting && this._touched) {\n        var offset = this.getOffset(e);\n        this._delta = {\n          x: this._pos.x - offset.x,\n          y: this._pos.y - offset.y\n        };\n        var delta = Math.abs(this._delta.x) + Math.abs(this._delta.y);\n\n        if (!distance && (!pressThreshold || pressThreshold && delta >= pressThreshold)) {\n          clearTimeout(this.cancelTimer);\n          this.cancelTimer = setTimeout(this.cancel, 0);\n        } else if (distance && delta >= distance && this.manager.isActive()) {\n          this.handlePress(e);\n        }\n      }\n    },\n    handleEnd: function handleEnd() {\n      var distance = this.$props.distance;\n\n\n      this._touched = false;\n\n      if (!distance) {\n        this.cancel();\n      }\n    },\n    cancel: function cancel() {\n      if (!this.sorting) {\n        clearTimeout(this.pressTimer);\n        this.manager.active = null;\n      }\n    },\n    handlePress: function handlePress(e) {\n      var _this4 = this;\n\n      e.stopPropagation();\n      var active = this.manager.getActive();\n\n      if (active) {\n        var _$props3 = this.$props,\n            axis = _$props3.axis,\n            getHelperDimensions = _$props3.getHelperDimensions,\n            helperClass = _$props3.helperClass,\n            hideSortableGhost = _$props3.hideSortableGhost,\n            useWindowAsScrollContainer = _$props3.useWindowAsScrollContainer,\n            appendTo = _$props3.appendTo;\n        var node = active.node,\n            collection = active.collection;\n        var index = node.sortableInfo.index;\n\n        var margin = getElementMargin(node);\n\n        var containerBoundingRect = this.container.getBoundingClientRect();\n        var dimensions = getHelperDimensions({ index: index, node: node, collection: collection });\n\n        this.node = node;\n        this.margin = margin;\n        this.width = dimensions.width;\n        this.height = dimensions.height;\n        this.marginOffset = {\n          x: this.margin.left + this.margin.right,\n          y: Math.max(this.margin.top, this.margin.bottom)\n        };\n        this.boundingClientRect = node.getBoundingClientRect();\n        this.containerBoundingRect = containerBoundingRect;\n        this.index = index;\n        this.newIndex = index;\n\n        this._axis = {\n          x: axis.indexOf('x') >= 0,\n          y: axis.indexOf('y') >= 0\n        };\n        this.offsetEdge = this.getEdgeOffset(node);\n        this.initialOffset = this.getOffset(e);\n        this.initialScroll = {\n          top: this.scrollContainer.scrollTop,\n          left: this.scrollContainer.scrollLeft\n        };\n\n        this.initialWindowScroll = {\n          top: window.pageYOffset,\n          left: window.pageXOffset\n        };\n\n        var fields = node.querySelectorAll('input, textarea, select');\n        var clonedNode = node.cloneNode(true);\n        var clonedFields = [].concat(toConsumableArray(clonedNode.querySelectorAll('input, textarea, select'))); // Convert NodeList to Array\n\n        clonedFields.forEach(function (field, index) {\n          if (field.type !== 'file' && fields[index]) {\n            field.value = fields[index].value;\n          }\n        });\n\n        this.helper = this.document.querySelector(appendTo).appendChild(clonedNode);\n\n        this.helper.style.position = 'fixed';\n        this.helper.style.top = this.boundingClientRect.top - margin.top + 'px';\n        this.helper.style.left = this.boundingClientRect.left - margin.left + 'px';\n        this.helper.style.width = this.width + 'px';\n        this.helper.style.height = this.height + 'px';\n        this.helper.style.boxSizing = 'border-box';\n        this.helper.style.pointerEvents = 'none';\n\n        if (hideSortableGhost) {\n          this.sortableGhost = node;\n          node.style.visibility = 'hidden';\n          node.style.opacity = 0;\n        }\n\n        this.translate = {};\n        this.minTranslate = {};\n        this.maxTranslate = {};\n        if (this._axis.x) {\n          this.minTranslate.x = (useWindowAsScrollContainer ? 0 : containerBoundingRect.left) - this.boundingClientRect.left - this.width / 2;\n          this.maxTranslate.x = (useWindowAsScrollContainer ? this._window.innerWidth : containerBoundingRect.left + containerBoundingRect.width) - this.boundingClientRect.left - this.width / 2;\n        }\n        if (this._axis.y) {\n          this.minTranslate.y = (useWindowAsScrollContainer ? 0 : containerBoundingRect.top) - this.boundingClientRect.top - this.height / 2;\n          this.maxTranslate.y = (useWindowAsScrollContainer ? this._window.innerHeight : containerBoundingRect.top + containerBoundingRect.height) - this.boundingClientRect.top - this.height / 2;\n        }\n\n        if (helperClass) {\n          var _helper$classList;\n\n          (_helper$classList = this.helper.classList).add.apply(_helper$classList, toConsumableArray(helperClass.split(' ')));\n        }\n\n        this.listenerNode = e.touches ? node : this._window;\n        events.move.forEach(function (eventName) {\n          return _this4.listenerNode.addEventListener(eventName, _this4.handleSortMove, false);\n        });\n        events.end.forEach(function (eventName) {\n          return _this4.listenerNode.addEventListener(eventName, _this4.handleSortEnd, false);\n        });\n\n        this.sorting = true;\n        this.sortingIndex = index;\n\n        this.$emit('sort-start', { event: e, node: node, index: index, collection: collection });\n      }\n    },\n    handleSortMove: function handleSortMove(e) {\n      e.preventDefault(); // Prevent scrolling on mobile\n\n      this.updatePosition(e);\n      this.animateNodes();\n      this.autoscroll();\n\n      this.$emit('sort-move', { event: e });\n    },\n    handleSortEnd: function handleSortEnd(e) {\n      var _this5 = this;\n\n      var collection = this.manager.active.collection;\n\n      // Remove the event listeners if the node is still in the DOM\n\n      if (this.listenerNode) {\n        events.move.forEach(function (eventName) {\n          return _this5.listenerNode.removeEventListener(eventName, _this5.handleSortMove);\n        });\n        events.end.forEach(function (eventName) {\n          return _this5.listenerNode.removeEventListener(eventName, _this5.handleSortEnd);\n        });\n      }\n\n      var nodes = this.manager.refs[collection];\n\n      var onEnd = function onEnd() {\n        // Remove the helper from the DOM\n        _this5.helper.parentNode.removeChild(_this5.helper);\n\n        if (_this5.hideSortableGhost && _this5.sortableGhost) {\n          _this5.sortableGhost.style.visibility = '';\n          _this5.sortableGhost.style.opacity = '';\n        }\n\n        for (var i = 0, len = nodes.length; i < len; i++) {\n          var node = nodes[i];\n          var el = node.node;\n\n          // Clear the cached offsetTop / offsetLeft value\n          node.edgeOffset = null;\n\n          // Remove the transforms / transitions\n          el.style[vendorPrefix + 'Transform'] = '';\n          el.style[vendorPrefix + 'TransitionDuration'] = '';\n        }\n\n        // Stop autoscroll\n        clearInterval(_this5.autoscrollInterval);\n        _this5.autoscrollInterval = null;\n\n        // Update state\n        _this5.manager.active = null;\n\n        _this5.sorting = false;\n        _this5.sortingIndex = null;\n\n        _this5.$emit('sort-end', {\n          event: e,\n          oldIndex: _this5.index,\n          newIndex: _this5.newIndex,\n          collection: collection\n        });\n        _this5.$emit('input', arrayMove(_this5.value, _this5.index, _this5.newIndex));\n\n        _this5._touched = false;\n      };\n\n      if (this.$props.transitionDuration || this.$props.draggedSettlingDuration) {\n        this.transitionHelperIntoPlace(nodes).then(function () {\n          return onEnd();\n        });\n      } else {\n        onEnd();\n      }\n    },\n    transitionHelperIntoPlace: function transitionHelperIntoPlace(nodes) {\n      var _this6 = this;\n\n      if (this.$props.draggedSettlingDuration === 0 || nodes.length === 0) {\n        return Promise.resolve();\n      }\n\n      var deltaScroll = {\n        left: this.scrollContainer.scrollLeft - this.initialScroll.left,\n        top: this.scrollContainer.scrollTop - this.initialScroll.top\n      };\n      var indexNode = nodes[this.index].node;\n      var newIndexNode = nodes[this.newIndex].node;\n\n      var targetX = -deltaScroll.left;\n      if (this.translate && this.translate.x > 0) {\n        // Diff against right edge when moving to the right\n        targetX += newIndexNode.offsetLeft + newIndexNode.offsetWidth - (indexNode.offsetLeft + indexNode.offsetWidth);\n      } else {\n        targetX += newIndexNode.offsetLeft - indexNode.offsetLeft;\n      }\n\n      var targetY = -deltaScroll.top;\n      if (this.translate && this.translate.y > 0) {\n        // Diff against the bottom edge when moving down\n        targetY += newIndexNode.offsetTop + newIndexNode.offsetHeight - (indexNode.offsetTop + indexNode.offsetHeight);\n      } else {\n        targetY += newIndexNode.offsetTop - indexNode.offsetTop;\n      }\n\n      var duration = this.$props.draggedSettlingDuration !== null ? this.$props.draggedSettlingDuration : this.$props.transitionDuration;\n\n      this.helper.style[vendorPrefix + 'Transform'] = 'translate3d(' + targetX + 'px,' + targetY + 'px, 0)';\n      this.helper.style[vendorPrefix + 'TransitionDuration'] = duration + 'ms';\n\n      return new Promise(function (resolve) {\n        // Register an event handler to clean up styles when the transition\n        // finishes.\n        var cleanup = function cleanup(event) {\n          if (!event || event.propertyName === 'transform') {\n            clearTimeout(cleanupTimer);\n            _this6.helper.style[vendorPrefix + 'Transform'] = '';\n            _this6.helper.style[vendorPrefix + 'TransitionDuration'] = '';\n            resolve();\n          }\n        };\n        // Force cleanup in case 'transitionend' never fires\n        var cleanupTimer = setTimeout(cleanup, duration + 10);\n        _this6.helper.addEventListener('transitionend', cleanup, false);\n      });\n    },\n    getEdgeOffset: function getEdgeOffset(node) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { top: 0, left: 0 };\n\n      // Get the actual offsetTop / offsetLeft value, no matter how deep the node is nested\n      if (node) {\n        var nodeOffset = {\n          top: offset.top + node.offsetTop,\n          left: offset.left + node.offsetLeft\n        };\n        if (node.parentNode !== this.container) {\n          return this.getEdgeOffset(node.parentNode, nodeOffset);\n        } else {\n          return nodeOffset;\n        }\n      }\n    },\n    getOffset: function getOffset(e) {\n      var _ref2 = e.touches ? e.touches[0] : e,\n          pageX = _ref2.pageX,\n          pageY = _ref2.pageY;\n\n      return {\n        x: pageX,\n        y: pageY\n      };\n    },\n    getLockPixelOffsets: function getLockPixelOffsets() {\n      var lockOffset = this.$props.lockOffset;\n\n\n      if (!Array.isArray(this.lockOffset)) {\n        lockOffset = [lockOffset, lockOffset];\n      }\n\n      if (lockOffset.length !== 2) {\n        throw new Error('lockOffset prop of SortableContainer should be a single value or an array of exactly two values. Given ' + lockOffset);\n      }\n\n      var _lockOffset = lockOffset,\n          _lockOffset2 = slicedToArray(_lockOffset, 2),\n          minLockOffset = _lockOffset2[0],\n          maxLockOffset = _lockOffset2[1];\n\n      return [this.getLockPixelOffset(minLockOffset), this.getLockPixelOffset(maxLockOffset)];\n    },\n    getLockPixelOffset: function getLockPixelOffset(lockOffset) {\n      var offsetX = lockOffset;\n      var offsetY = lockOffset;\n      var unit = 'px';\n\n      if (typeof lockOffset === 'string') {\n        var match = /^[+-]?\\d*(?:\\.\\d*)?(px|%)$/.exec(lockOffset);\n\n        if (match === null) {\n          throw new Error('lockOffset value should be a number or a string of a number followed by \"px\" or \"%\". Given ' + lockOffset);\n        }\n\n        offsetX = offsetY = parseFloat(lockOffset);\n        unit = match[1];\n      }\n\n      if (!isFinite(offsetX) || !isFinite(offsetY)) {\n        throw new Error('lockOffset value should be a finite. Given ' + lockOffset);\n      }\n\n      if (unit === '%') {\n        offsetX = offsetX * this.width / 100;\n        offsetY = offsetY * this.height / 100;\n      }\n\n      return {\n        x: offsetX,\n        y: offsetY\n      };\n    },\n    updatePosition: function updatePosition(e) {\n      var _$props4 = this.$props,\n          lockAxis = _$props4.lockAxis,\n          lockToContainerEdges = _$props4.lockToContainerEdges;\n\n\n      var offset = this.getOffset(e);\n      var translate = {\n        x: offset.x - this.initialOffset.x,\n        y: offset.y - this.initialOffset.y\n      };\n      // Adjust for window scroll\n      translate.y -= window.pageYOffset - this.initialWindowScroll.top;\n      translate.x -= window.pageXOffset - this.initialWindowScroll.left;\n\n      this.translate = translate;\n\n      if (lockToContainerEdges) {\n        var _getLockPixelOffsets = this.getLockPixelOffsets(),\n            _getLockPixelOffsets2 = slicedToArray(_getLockPixelOffsets, 2),\n            minLockOffset = _getLockPixelOffsets2[0],\n            maxLockOffset = _getLockPixelOffsets2[1];\n\n        var minOffset = {\n          x: this.width / 2 - minLockOffset.x,\n          y: this.height / 2 - minLockOffset.y\n        };\n        var maxOffset = {\n          x: this.width / 2 - maxLockOffset.x,\n          y: this.height / 2 - maxLockOffset.y\n        };\n\n        translate.x = limit(this.minTranslate.x + minOffset.x, this.maxTranslate.x - maxOffset.x, translate.x);\n        translate.y = limit(this.minTranslate.y + minOffset.y, this.maxTranslate.y - maxOffset.y, translate.y);\n      }\n\n      if (lockAxis === 'x') {\n        translate.y = 0;\n      } else if (lockAxis === 'y') {\n        translate.x = 0;\n      }\n\n      this.helper.style[vendorPrefix + 'Transform'] = 'translate3d(' + translate.x + 'px,' + translate.y + 'px, 0)';\n    },\n    animateNodes: function animateNodes() {\n      var _$props5 = this.$props,\n          transitionDuration = _$props5.transitionDuration,\n          hideSortableGhost = _$props5.hideSortableGhost;\n\n      var nodes = this.manager.getOrderedRefs();\n      var deltaScroll = {\n        left: this.scrollContainer.scrollLeft - this.initialScroll.left,\n        top: this.scrollContainer.scrollTop - this.initialScroll.top\n      };\n      var sortingOffset = {\n        left: this.offsetEdge.left + this.translate.x + deltaScroll.left,\n        top: this.offsetEdge.top + this.translate.y + deltaScroll.top\n      };\n      var scrollDifference = {\n        top: window.pageYOffset - this.initialWindowScroll.top,\n        left: window.pageXOffset - this.initialWindowScroll.left\n      };\n      this.newIndex = null;\n\n      for (var i = 0, len = nodes.length; i < len; i++) {\n        var node = nodes[i].node;\n\n        var index = node.sortableInfo.index;\n        var width = node.offsetWidth;\n        var height = node.offsetHeight;\n        var offset = {\n          width: this.width > width ? width / 2 : this.width / 2,\n          height: this.height > height ? height / 2 : this.height / 2\n        };\n\n        var translate = {\n          x: 0,\n          y: 0\n        };\n        var edgeOffset = nodes[i].edgeOffset;\n\n        // If we haven't cached the node's offsetTop / offsetLeft value\n\n        if (!edgeOffset) {\n          nodes[i].edgeOffset = edgeOffset = this.getEdgeOffset(node);\n        }\n\n        // Get a reference to the next and previous node\n        var nextNode = i < nodes.length - 1 && nodes[i + 1];\n        var prevNode = i > 0 && nodes[i - 1];\n\n        // Also cache the next node's edge offset if needed.\n        // We need this for calculating the animation in a grid setup\n        if (nextNode && !nextNode.edgeOffset) {\n          nextNode.edgeOffset = this.getEdgeOffset(nextNode.node);\n        }\n\n        // If the node is the one we're currently animating, skip it\n        if (index === this.index) {\n          if (hideSortableGhost) {\n            /*\n            * With windowing libraries such as `react-virtualized`, the sortableGhost\n            * node may change while scrolling down and then back up (or vice-versa),\n            * so we need to update the reference to the new node just to be safe.\n            */\n            this.sortableGhost = node;\n            node.style.visibility = 'hidden';\n            node.style.opacity = 0;\n          }\n          continue;\n        }\n\n        if (transitionDuration) {\n          node.style[vendorPrefix + 'TransitionDuration'] = transitionDuration + 'ms';\n        }\n\n        if (this._axis.x) {\n          if (this._axis.y) {\n            // Calculations for a grid setup\n            if (index < this.index && (sortingOffset.left + scrollDifference.left - offset.width <= edgeOffset.left && sortingOffset.top + scrollDifference.top <= edgeOffset.top + offset.height || sortingOffset.top + scrollDifference.top + offset.height <= edgeOffset.top)) {\n              // If the current node is to the left on the same row, or above the node that's being dragged\n              // then move it to the right\n              translate.x = this.width + this.marginOffset.x;\n              if (edgeOffset.left + translate.x > this.containerBoundingRect.width - offset.width) {\n                // If it moves passed the right bounds, then animate it to the first position of the next row.\n                // We just use the offset of the next node to calculate where to move, because that node's original position\n                // is exactly where we want to go\n                translate.x = nextNode.edgeOffset.left - edgeOffset.left;\n                translate.y = nextNode.edgeOffset.top - edgeOffset.top;\n              }\n              if (this.newIndex === null) {\n                this.newIndex = index;\n              }\n            } else if (index > this.index && (sortingOffset.left + scrollDifference.left + offset.width >= edgeOffset.left && sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top || sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top + height)) {\n              // If the current node is to the right on the same row, or below the node that's being dragged\n              // then move it to the left\n              translate.x = -(this.width + this.marginOffset.x);\n              if (edgeOffset.left + translate.x < this.containerBoundingRect.left + offset.width) {\n                // If it moves passed the left bounds, then animate it to the last position of the previous row.\n                // We just use the offset of the previous node to calculate where to move, because that node's original position\n                // is exactly where we want to go\n                translate.x = prevNode.edgeOffset.left - edgeOffset.left;\n                translate.y = prevNode.edgeOffset.top - edgeOffset.top;\n              }\n              this.newIndex = index;\n            }\n          } else {\n            if (index > this.index && sortingOffset.left + scrollDifference.left + offset.width >= edgeOffset.left) {\n              translate.x = -(this.width + this.marginOffset.x);\n              this.newIndex = index;\n            } else if (index < this.index && sortingOffset.left + scrollDifference.left <= edgeOffset.left + offset.width) {\n              translate.x = this.width + this.marginOffset.x;\n              if (this.newIndex == null) {\n                this.newIndex = index;\n              }\n            }\n          }\n        } else if (this._axis.y) {\n          if (index > this.index && sortingOffset.top + scrollDifference.top + offset.height >= edgeOffset.top) {\n            translate.y = -(this.height + this.marginOffset.y);\n            this.newIndex = index;\n          } else if (index < this.index && sortingOffset.top + scrollDifference.top <= edgeOffset.top + offset.height) {\n            translate.y = this.height + this.marginOffset.y;\n            if (this.newIndex == null) {\n              this.newIndex = index;\n            }\n          }\n        }\n        node.style[vendorPrefix + 'Transform'] = 'translate3d(' + translate.x + 'px,' + translate.y + 'px,0)';\n      }\n\n      if (this.newIndex == null) {\n        this.newIndex = this.index;\n      }\n    },\n    autoscroll: function autoscroll() {\n      var _this7 = this;\n\n      var translate = this.translate;\n      var direction = {\n        x: 0,\n        y: 0\n      };\n      var speed = {\n        x: 1,\n        y: 1\n      };\n      var acceleration = {\n        x: 10,\n        y: 10\n      };\n\n      if (translate.y >= this.maxTranslate.y - this.height / 2) {\n        direction.y = 1; // Scroll Down\n        speed.y = acceleration.y * Math.abs((this.maxTranslate.y - this.height / 2 - translate.y) / this.height);\n      } else if (translate.x >= this.maxTranslate.x - this.width / 2) {\n        direction.x = 1; // Scroll Right\n        speed.x = acceleration.x * Math.abs((this.maxTranslate.x - this.width / 2 - translate.x) / this.width);\n      } else if (translate.y <= this.minTranslate.y + this.height / 2) {\n        direction.y = -1; // Scroll Up\n        speed.y = acceleration.y * Math.abs((translate.y - this.height / 2 - this.minTranslate.y) / this.height);\n      } else if (translate.x <= this.minTranslate.x + this.width / 2) {\n        direction.x = -1; // Scroll Left\n        speed.x = acceleration.x * Math.abs((translate.x - this.width / 2 - this.minTranslate.x) / this.width);\n      }\n\n      if (this.autoscrollInterval) {\n        clearInterval(this.autoscrollInterval);\n        this.autoscrollInterval = null;\n        this.isAutoScrolling = false;\n      }\n\n      if (direction.x !== 0 || direction.y !== 0) {\n        this.autoscrollInterval = setInterval(function () {\n          _this7.isAutoScrolling = true;\n          var offset = {\n            left: 1 * speed.x * direction.x,\n            top: 1 * speed.y * direction.y\n          };\n          _this7.scrollContainer.scrollTop += offset.top;\n          _this7.scrollContainer.scrollLeft += offset.left;\n          _this7.translate.x += offset.left;\n          _this7.translate.y += offset.top;\n          _this7.animateNodes();\n        }, 5);\n      }\n    }\n  }\n};\n\n// Export Sortable Element Handle Directive\nvar HandleDirective = {\n  bind: function bind(el) {\n    el.sortableHandle = true;\n  }\n};\n\nfunction create(name, mixin) {\n  return {\n    name: name,\n    mixins: [mixin],\n    props: {\n      tag: {\n        type: String,\n        default: 'div'\n      }\n    },\n    render: function render(h) {\n      return h(this.tag, this.$slots.default);\n    }\n  };\n}\n\nvar SlickList = create('slick-list', ContainerMixin);\nvar SlickItem = create('slick-item', ElementMixin);\n\nexports.ElementMixin = ElementMixin;\nexports.ContainerMixin = ContainerMixin;\nexports.HandleDirective = HandleDirective;\nexports.SlickList = SlickList;\nexports.SlickItem = SlickItem;\nexports.arrayMove = arrayMove;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLXNsaWNrc29ydC9kaXN0L3Z1ZS1zbGlja3NvcnQudW1kLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8kQmNsLy4vbm9kZV9tb2R1bGVzL3Z1ZS1zbGlja3NvcnQvZGlzdC92dWUtc2xpY2tzb3J0LnVtZC5qcz8xMWIwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5WdWVTbGlja3NvcnQgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gRXhwb3J0IFNvcnRhYmxlIEVsZW1lbnQgQ29tcG9uZW50IE1peGluXG52YXIgRWxlbWVudE1peGluID0ge1xuICBpbmplY3Q6IFsnbWFuYWdlciddLFxuICBwcm9wczoge1xuICAgIGluZGV4OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6ICdkZWZhdWx0J1xuICAgIH0sXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfSxcblxuICBtb3VudGVkOiBmdW5jdGlvbiBtb3VudGVkKCkge1xuICAgIHZhciBfJHByb3BzID0gdGhpcy4kcHJvcHMsXG4gICAgICAgIGNvbGxlY3Rpb24gPSBfJHByb3BzLmNvbGxlY3Rpb24sXG4gICAgICAgIGRpc2FibGVkID0gXyRwcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgaW5kZXggPSBfJHByb3BzLmluZGV4O1xuXG5cbiAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICB0aGlzLnNldERyYWdnYWJsZShjb2xsZWN0aW9uLCBpbmRleCk7XG4gICAgfVxuICB9LFxuXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmRleDogZnVuY3Rpb24gaW5kZXgobmV3SW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLiRlbCAmJiB0aGlzLiRlbC5zb3J0YWJsZUluZm8pIHtcbiAgICAgICAgdGhpcy4kZWwuc29ydGFibGVJbmZvLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoaXNEaXNhYmxlZCkge1xuICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVEcmFnZ2FibGUodGhpcy5jb2xsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RHJhZ2dhYmxlKHRoaXMuY29sbGVjdGlvbiwgdGhpcy5pbmRleCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb2xsZWN0aW9uOiBmdW5jdGlvbiBjb2xsZWN0aW9uKG5ld0NvbGxlY3Rpb24sIG9sZENvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMucmVtb3ZlRHJhZ2dhYmxlKG9sZENvbGxlY3Rpb24pO1xuICAgICAgdGhpcy5zZXREcmFnZ2FibGUobmV3Q29sbGVjdGlvbiwgdGhpcy5pbmRleCk7XG4gICAgfVxuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb24sXG4gICAgICAgIGRpc2FibGVkID0gdGhpcy5kaXNhYmxlZDtcblxuXG4gICAgaWYgKCFkaXNhYmxlZCkgdGhpcy5yZW1vdmVEcmFnZ2FibGUoY29sbGVjdGlvbik7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIHNldERyYWdnYWJsZTogZnVuY3Rpb24gc2V0RHJhZ2dhYmxlKGNvbGxlY3Rpb24sIGluZGV4KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuJGVsO1xuXG4gICAgICBub2RlLnNvcnRhYmxlSW5mbyA9IHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgICAgICBtYW5hZ2VyOiB0aGlzLm1hbmFnZXJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucmVmID0geyBub2RlOiBub2RlIH07XG4gICAgICB0aGlzLm1hbmFnZXIuYWRkKGNvbGxlY3Rpb24sIHRoaXMucmVmKTtcbiAgICB9LFxuICAgIHJlbW92ZURyYWdnYWJsZTogZnVuY3Rpb24gcmVtb3ZlRHJhZ2dhYmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMubWFuYWdlci5yZW1vdmUoY29sbGVjdGlvbiwgdGhpcy5yZWYpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBzbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkge1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX2UgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gdHJ1ZTtcbiAgICAgIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2FycjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gICAgcmV0dXJuIGFycjI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgfVxufTtcblxudmFyIE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hbmFnZXIoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFuYWdlcik7XG5cbiAgICB0aGlzLnJlZnMgPSB7fTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKE1hbmFnZXIsIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoY29sbGVjdGlvbiwgcmVmKSB7XG4gICAgICBpZiAoIXRoaXMucmVmc1tjb2xsZWN0aW9uXSkge1xuICAgICAgICB0aGlzLnJlZnNbY29sbGVjdGlvbl0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZWZzW2NvbGxlY3Rpb25dLnB1c2gocmVmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShjb2xsZWN0aW9uLCByZWYpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoY29sbGVjdGlvbiwgcmVmKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICB0aGlzLnJlZnNbY29sbGVjdGlvbl0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBY3RpdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFjdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBY3RpdmUoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5yZWZzW3RoaXMuYWN0aXZlLmNvbGxlY3Rpb25dLmZpbmQoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBfcmVmLm5vZGU7XG4gICAgICAgIHJldHVybiBub2RlLnNvcnRhYmxlSW5mby5pbmRleCA9PSBfdGhpcy5hY3RpdmUuaW5kZXg7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgoY29sbGVjdGlvbiwgcmVmKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZzW2NvbGxlY3Rpb25dLmluZGV4T2YocmVmKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3JkZXJlZFJlZnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JkZXJlZFJlZnMoKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5hY3RpdmUuY29sbGVjdGlvbjtcblxuICAgICAgcmV0dXJuIHRoaXMucmVmc1tjb2xsZWN0aW9uXS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm5vZGUuc29ydGFibGVJbmZvLmluZGV4IC0gYi5ub2RlLnNvcnRhYmxlSW5mby5pbmRleDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWFuYWdlcjtcbn0oKTtcblxuZnVuY3Rpb24gYXJyYXlNb3ZlKGFyciwgcHJldmlvdXNJbmRleCwgbmV3SW5kZXgpIHtcbiAgdmFyIGFycmF5ID0gYXJyLnNsaWNlKDApO1xuICBpZiAobmV3SW5kZXggPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgdmFyIGsgPSBuZXdJbmRleCAtIGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoay0tICsgMSkge1xuICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuICBhcnJheS5zcGxpY2UobmV3SW5kZXgsIDAsIGFycmF5LnNwbGljZShwcmV2aW91c0luZGV4LCAxKVswXSk7XG4gIHJldHVybiBhcnJheTtcbn1cblxudmFyIGV2ZW50cyA9IHtcbiAgc3RhcnQ6IFsndG91Y2hzdGFydCcsICdtb3VzZWRvd24nXSxcbiAgbW92ZTogWyd0b3VjaG1vdmUnLCAnbW91c2Vtb3ZlJ10sXG4gIGVuZDogWyd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcsICdtb3VzZXVwJ11cbn07XG5cbnZhciB2ZW5kb3JQcmVmaXggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7IC8vIHNlcnZlciBlbnZpcm9ubWVudFxuICAvLyBmaXggZm9yOlxuICAvLyAgICBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAgLy8gICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoKSByZXR1cm5zIG51bGwgaW5zaWRlIGFuIGlmcmFtZSB3aXRoIGRpc3BsYXk6IG5vbmVcbiAgLy8gaW4gdGhpcyBjYXNlIHJldHVybiBhbiBhcnJheSB3aXRoIGEgZmFrZSBtb3ppbGxhIHN0eWxlIGluIGl0LlxuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAnJykgfHwgWyctbW96LWhpZGRlbi1pZnJhbWUnXTtcbiAgdmFyIHByZSA9IChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzdHlsZXMpLmpvaW4oJycpLm1hdGNoKC8tKG1venx3ZWJraXR8bXMpLS8pIHx8IHN0eWxlcy5PTGluayA9PT0gJycgJiYgWycnLCAnbyddKVsxXTtcblxuICBzd2l0Y2ggKHByZSkge1xuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiAnbXMnO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gcHJlICYmIHByZS5sZW5ndGggPyBwcmVbMF0udG9VcHBlckNhc2UoKSArIHByZS5zdWJzdHIoMSkgOiAnJztcbiAgfVxufSgpO1xuXG5mdW5jdGlvbiBjbG9zZXN0KGVsLCBmbikge1xuICB3aGlsZSAoZWwpIHtcbiAgICBpZiAoZm4oZWwpKSByZXR1cm4gZWw7XG4gICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpbWl0KG1pbiwgbWF4LCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGlmICh2YWx1ZSA+IG1heCkge1xuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRDU1NQaXhlbFZhbHVlKHN0cmluZ1ZhbHVlKSB7XG4gIGlmIChzdHJpbmdWYWx1ZS5zdWJzdHIoLTIpID09PSAncHgnKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoc3RyaW5nVmFsdWUpO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBnZXRFbGVtZW50TWFyZ2luKGVsZW1lbnQpIHtcbiAgdmFyIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IGdldENTU1BpeGVsVmFsdWUoc3R5bGUubWFyZ2luVG9wKSxcbiAgICByaWdodDogZ2V0Q1NTUGl4ZWxWYWx1ZShzdHlsZS5tYXJnaW5SaWdodCksXG4gICAgYm90dG9tOiBnZXRDU1NQaXhlbFZhbHVlKHN0eWxlLm1hcmdpbkJvdHRvbSksXG4gICAgbGVmdDogZ2V0Q1NTUGl4ZWxWYWx1ZShzdHlsZS5tYXJnaW5MZWZ0KVxuICB9O1xufVxuXG4vLyBFeHBvcnQgU29ydGFibGUgQ29udGFpbmVyIENvbXBvbmVudCBNaXhpblxudmFyIENvbnRhaW5lck1peGluID0ge1xuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzb3J0aW5nOiBmYWxzZSxcbiAgICAgIHNvcnRpbmdJbmRleDogbnVsbCxcbiAgICAgIG1hbmFnZXI6IG5ldyBNYW5hZ2VyKCksXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuaGFuZGxlU3RhcnQsXG4gICAgICAgIG1vdmU6IHRoaXMuaGFuZGxlTW92ZSxcbiAgICAgICAgZW5kOiB0aGlzLmhhbmRsZUVuZFxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cblxuICBwcm9wczoge1xuICAgIHZhbHVlOiB7IHR5cGU6IEFycmF5LCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgIGF4aXM6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAneScgfSwgLy8gJ3gnLCAneScsICd4eSdcbiAgICBkaXN0YW5jZTogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IDAgfSxcbiAgICBwcmVzc0RlbGF5OiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMCB9LFxuICAgIHByZXNzVGhyZXNob2xkOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogNSB9LFxuICAgIHVzZURyYWdIYW5kbGU6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICB1c2VXaW5kb3dBc1Njcm9sbENvbnRhaW5lcjogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIGhpZGVTb3J0YWJsZUdob3N0OiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfSxcbiAgICBsb2NrVG9Db250YWluZXJFZGdlczogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiBmYWxzZSB9LFxuICAgIGxvY2tPZmZzZXQ6IHsgdHlwZTogW1N0cmluZywgTnVtYmVyLCBBcnJheV0sIGRlZmF1bHQ6ICc1MCUnIH0sXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMzAwIH0sXG4gICAgYXBwZW5kVG86IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnYm9keScgfSxcbiAgICBkcmFnZ2VkU2V0dGxpbmdEdXJhdGlvbjogeyB0eXBlOiBOdW1iZXIsIGRlZmF1bHQ6IG51bGwgfSxcbiAgICBsb2NrQXhpczogU3RyaW5nLFxuICAgIGhlbHBlckNsYXNzOiBTdHJpbmcsXG4gICAgY29udGVudFdpbmRvdzogT2JqZWN0LFxuICAgIHNob3VsZENhbmNlbFN0YXJ0OiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KGUpIHtcbiAgICAgICAgLy8gQ2FuY2VsIHNvcnRpbmcgaWYgdGhlIGV2ZW50IHRhcmdldCBpcyBhbiBgaW5wdXRgLCBgdGV4dGFyZWFgLCBgc2VsZWN0YCBvciBgb3B0aW9uYFxuICAgICAgICB2YXIgZGlzYWJsZWRFbGVtZW50cyA9IFsnaW5wdXQnLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ29wdGlvbicsICdidXR0b24nXTtcbiAgICAgICAgcmV0dXJuIGRpc2FibGVkRWxlbWVudHMuaW5kZXhPZihlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICE9PSAtMTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEhlbHBlckRpbWVuc2lvbnM6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoX3JlZikge1xuICAgICAgICB2YXIgbm9kZSA9IF9yZWYubm9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogbm9kZS5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IG5vZGUub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHByb3ZpZGU6IGZ1bmN0aW9uIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hbmFnZXI6IHRoaXMubWFuYWdlclxuICAgIH07XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy4kZWw7XG4gICAgdGhpcy5kb2N1bWVudCA9IHRoaXMuY29udGFpbmVyLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgdGhpcy5fd2luZG93ID0gdGhpcy5jb250ZW50V2luZG93IHx8IHdpbmRvdztcbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lciA9IHRoaXMudXNlV2luZG93QXNTY3JvbGxDb250YWluZXIgPyB0aGlzLmRvY3VtZW50LmJvZHkgOiB0aGlzLmNvbnRhaW5lcjtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGtleSkge1xuICAgICAgaWYgKF90aGlzLmV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGV2ZW50c1trZXldLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIF90aGlzLmV2ZW50c1trZXldLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgIF9sb29wKGtleSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihrZXkpIHtcbiAgICAgIGlmIChfdGhpczIuZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZXZlbnRzW2tleV0uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIF90aGlzMi5ldmVudHNba2V5XSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgIF9sb29wMihrZXkpO1xuICAgIH1cbiAgfSxcblxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVTdGFydDogZnVuY3Rpb24gaGFuZGxlU3RhcnQoZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBfJHByb3BzID0gdGhpcy4kcHJvcHMsXG4gICAgICAgICAgZGlzdGFuY2UgPSBfJHByb3BzLmRpc3RhbmNlLFxuICAgICAgICAgIHNob3VsZENhbmNlbFN0YXJ0ID0gXyRwcm9wcy5zaG91bGRDYW5jZWxTdGFydDtcblxuXG4gICAgICBpZiAoZS5idXR0b24gPT09IDIgfHwgc2hvdWxkQ2FuY2VsU3RhcnQoZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl90b3VjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3BvcyA9IHRoaXMuZ2V0T2Zmc2V0KGUpO1xuXG4gICAgICB2YXIgbm9kZSA9IGNsb3Nlc3QoZS50YXJnZXQsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwuc29ydGFibGVJbmZvICE9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgaWYgKG5vZGUgJiYgbm9kZS5zb3J0YWJsZUluZm8gJiYgdGhpcy5ub2RlSXNDaGlsZChub2RlKSAmJiAhdGhpcy5zb3J0aW5nKSB7XG4gICAgICAgIHZhciB1c2VEcmFnSGFuZGxlID0gdGhpcy4kcHJvcHMudXNlRHJhZ0hhbmRsZTtcbiAgICAgICAgdmFyIF9ub2RlJHNvcnRhYmxlSW5mbyA9IG5vZGUuc29ydGFibGVJbmZvLFxuICAgICAgICAgICAgaW5kZXggPSBfbm9kZSRzb3J0YWJsZUluZm8uaW5kZXgsXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gX25vZGUkc29ydGFibGVJbmZvLmNvbGxlY3Rpb247XG5cblxuICAgICAgICBpZiAodXNlRHJhZ0hhbmRsZSAmJiAhY2xvc2VzdChlLnRhcmdldCwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLnNvcnRhYmxlSGFuZGxlICE9IG51bGw7XG4gICAgICAgIH0pKSByZXR1cm47XG5cbiAgICAgICAgdGhpcy5tYW5hZ2VyLmFjdGl2ZSA9IHsgaW5kZXg6IGluZGV4LCBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgKiBGaXhlcyBhIGJ1ZyBpbiBGaXJlZm94IHdoZXJlIHRoZSA6YWN0aXZlIHN0YXRlIG9mIGFuY2hvciB0YWdzXG4gICAgICAgICogcHJldmVudCBzdWJzZXF1ZW50ICdtb3VzZW1vdmUnIGV2ZW50cyBmcm9tIGJlaW5nIGZpcmVkXG4gICAgICAgICogKHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2xhdWRlcmljL3JlYWN0LXNvcnRhYmxlLWhvYy9pc3N1ZXMvMTE4KVxuICAgICAgICAqL1xuICAgICAgICBpZiAoZS50YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnYScpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKHRoaXMuJHByb3BzLnByZXNzRGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUHJlc3MoZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmhhbmRsZVByZXNzKGUpO1xuICAgICAgICAgICAgfSwgdGhpcy4kcHJvcHMucHJlc3NEZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBub2RlSXNDaGlsZDogZnVuY3Rpb24gbm9kZUlzQ2hpbGQobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuc29ydGFibGVJbmZvLm1hbmFnZXIgPT09IHRoaXMubWFuYWdlcjtcbiAgICB9LFxuICAgIGhhbmRsZU1vdmU6IGZ1bmN0aW9uIGhhbmRsZU1vdmUoZSkge1xuICAgICAgdmFyIF8kcHJvcHMyID0gdGhpcy4kcHJvcHMsXG4gICAgICAgICAgZGlzdGFuY2UgPSBfJHByb3BzMi5kaXN0YW5jZSxcbiAgICAgICAgICBwcmVzc1RocmVzaG9sZCA9IF8kcHJvcHMyLnByZXNzVGhyZXNob2xkO1xuXG5cbiAgICAgIGlmICghdGhpcy5zb3J0aW5nICYmIHRoaXMuX3RvdWNoZWQpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0KGUpO1xuICAgICAgICB0aGlzLl9kZWx0YSA9IHtcbiAgICAgICAgICB4OiB0aGlzLl9wb3MueCAtIG9mZnNldC54LFxuICAgICAgICAgIHk6IHRoaXMuX3Bvcy55IC0gb2Zmc2V0LnlcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnModGhpcy5fZGVsdGEueCkgKyBNYXRoLmFicyh0aGlzLl9kZWx0YS55KTtcblxuICAgICAgICBpZiAoIWRpc3RhbmNlICYmICghcHJlc3NUaHJlc2hvbGQgfHwgcHJlc3NUaHJlc2hvbGQgJiYgZGVsdGEgPj0gcHJlc3NUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2FuY2VsVGltZXIpO1xuICAgICAgICAgIHRoaXMuY2FuY2VsVGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuY2FuY2VsLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZSAmJiBkZWx0YSA+PSBkaXN0YW5jZSAmJiB0aGlzLm1hbmFnZXIuaXNBY3RpdmUoKSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlUHJlc3MoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZUVuZDogZnVuY3Rpb24gaGFuZGxlRW5kKCkge1xuICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy4kcHJvcHMuZGlzdGFuY2U7XG5cblxuICAgICAgdGhpcy5fdG91Y2hlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoIWRpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIGlmICghdGhpcy5zb3J0aW5nKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnByZXNzVGltZXIpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuYWN0aXZlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVByZXNzOiBmdW5jdGlvbiBoYW5kbGVQcmVzcyhlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHZhciBhY3RpdmUgPSB0aGlzLm1hbmFnZXIuZ2V0QWN0aXZlKCk7XG5cbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgdmFyIF8kcHJvcHMzID0gdGhpcy4kcHJvcHMsXG4gICAgICAgICAgICBheGlzID0gXyRwcm9wczMuYXhpcyxcbiAgICAgICAgICAgIGdldEhlbHBlckRpbWVuc2lvbnMgPSBfJHByb3BzMy5nZXRIZWxwZXJEaW1lbnNpb25zLFxuICAgICAgICAgICAgaGVscGVyQ2xhc3MgPSBfJHByb3BzMy5oZWxwZXJDbGFzcyxcbiAgICAgICAgICAgIGhpZGVTb3J0YWJsZUdob3N0ID0gXyRwcm9wczMuaGlkZVNvcnRhYmxlR2hvc3QsXG4gICAgICAgICAgICB1c2VXaW5kb3dBc1Njcm9sbENvbnRhaW5lciA9IF8kcHJvcHMzLnVzZVdpbmRvd0FzU2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICAgICAgYXBwZW5kVG8gPSBfJHByb3BzMy5hcHBlbmRUbztcbiAgICAgICAgdmFyIG5vZGUgPSBhY3RpdmUubm9kZSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBhY3RpdmUuY29sbGVjdGlvbjtcbiAgICAgICAgdmFyIGluZGV4ID0gbm9kZS5zb3J0YWJsZUluZm8uaW5kZXg7XG5cbiAgICAgICAgdmFyIG1hcmdpbiA9IGdldEVsZW1lbnRNYXJnaW4obm9kZSk7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lckJvdW5kaW5nUmVjdCA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IGdldEhlbHBlckRpbWVuc2lvbnMoeyBpbmRleDogaW5kZXgsIG5vZGU6IG5vZGUsIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24gfSk7XG5cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5tYXJnaW4gPSBtYXJnaW47XG4gICAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLm1hcmdpbk9mZnNldCA9IHtcbiAgICAgICAgICB4OiB0aGlzLm1hcmdpbi5sZWZ0ICsgdGhpcy5tYXJnaW4ucmlnaHQsXG4gICAgICAgICAgeTogTWF0aC5tYXgodGhpcy5tYXJnaW4udG9wLCB0aGlzLm1hcmdpbi5ib3R0b20pXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm91bmRpbmdDbGllbnRSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJCb3VuZGluZ1JlY3QgPSBjb250YWluZXJCb3VuZGluZ1JlY3Q7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5uZXdJbmRleCA9IGluZGV4O1xuXG4gICAgICAgIHRoaXMuX2F4aXMgPSB7XG4gICAgICAgICAgeDogYXhpcy5pbmRleE9mKCd4JykgPj0gMCxcbiAgICAgICAgICB5OiBheGlzLmluZGV4T2YoJ3knKSA+PSAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2Zmc2V0RWRnZSA9IHRoaXMuZ2V0RWRnZU9mZnNldChub2RlKTtcbiAgICAgICAgdGhpcy5pbml0aWFsT2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXQoZSk7XG4gICAgICAgIHRoaXMuaW5pdGlhbFNjcm9sbCA9IHtcbiAgICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCxcbiAgICAgICAgICBsZWZ0OiB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5pbml0aWFsV2luZG93U2Nyb2xsID0ge1xuICAgICAgICAgIHRvcDogd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICAgIGxlZnQ6IHdpbmRvdy5wYWdlWE9mZnNldFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBmaWVsZHMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0Jyk7XG4gICAgICAgIHZhciBjbG9uZWROb2RlID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIHZhciBjbG9uZWRGaWVsZHMgPSBbXS5jb25jYXQodG9Db25zdW1hYmxlQXJyYXkoY2xvbmVkTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCcpKSk7IC8vIENvbnZlcnQgTm9kZUxpc3QgdG8gQXJyYXlcblxuICAgICAgICBjbG9uZWRGaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGluZGV4KSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnR5cGUgIT09ICdmaWxlJyAmJiBmaWVsZHNbaW5kZXhdKSB7XG4gICAgICAgICAgICBmaWVsZC52YWx1ZSA9IGZpZWxkc1tpbmRleF0udmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmhlbHBlciA9IHRoaXMuZG9jdW1lbnQucXVlcnlTZWxlY3RvcihhcHBlbmRUbykuYXBwZW5kQ2hpbGQoY2xvbmVkTm9kZSk7XG5cbiAgICAgICAgdGhpcy5oZWxwZXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICB0aGlzLmhlbHBlci5zdHlsZS50b3AgPSB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdC50b3AgLSBtYXJnaW4udG9wICsgJ3B4JztcbiAgICAgICAgdGhpcy5oZWxwZXIuc3R5bGUubGVmdCA9IHRoaXMuYm91bmRpbmdDbGllbnRSZWN0LmxlZnQgLSBtYXJnaW4ubGVmdCArICdweCc7XG4gICAgICAgIHRoaXMuaGVscGVyLnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuaGVscGVyLnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5oZWxwZXIuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgICAgICB0aGlzLmhlbHBlci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgICAgIGlmIChoaWRlU29ydGFibGVHaG9zdCkge1xuICAgICAgICAgIHRoaXMuc29ydGFibGVHaG9zdCA9IG5vZGU7XG4gICAgICAgICAgbm9kZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJhbnNsYXRlID0ge307XG4gICAgICAgIHRoaXMubWluVHJhbnNsYXRlID0ge307XG4gICAgICAgIHRoaXMubWF4VHJhbnNsYXRlID0ge307XG4gICAgICAgIGlmICh0aGlzLl9heGlzLngpIHtcbiAgICAgICAgICB0aGlzLm1pblRyYW5zbGF0ZS54ID0gKHVzZVdpbmRvd0FzU2Nyb2xsQ29udGFpbmVyID8gMCA6IGNvbnRhaW5lckJvdW5kaW5nUmVjdC5sZWZ0KSAtIHRoaXMuYm91bmRpbmdDbGllbnRSZWN0LmxlZnQgLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgICB0aGlzLm1heFRyYW5zbGF0ZS54ID0gKHVzZVdpbmRvd0FzU2Nyb2xsQ29udGFpbmVyID8gdGhpcy5fd2luZG93LmlubmVyV2lkdGggOiBjb250YWluZXJCb3VuZGluZ1JlY3QubGVmdCArIGNvbnRhaW5lckJvdW5kaW5nUmVjdC53aWR0aCkgLSB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2F4aXMueSkge1xuICAgICAgICAgIHRoaXMubWluVHJhbnNsYXRlLnkgPSAodXNlV2luZG93QXNTY3JvbGxDb250YWluZXIgPyAwIDogY29udGFpbmVyQm91bmRpbmdSZWN0LnRvcCkgLSB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdC50b3AgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICAgICAgdGhpcy5tYXhUcmFuc2xhdGUueSA9ICh1c2VXaW5kb3dBc1Njcm9sbENvbnRhaW5lciA/IHRoaXMuX3dpbmRvdy5pbm5lckhlaWdodCA6IGNvbnRhaW5lckJvdW5kaW5nUmVjdC50b3AgKyBjb250YWluZXJCb3VuZGluZ1JlY3QuaGVpZ2h0KSAtIHRoaXMuYm91bmRpbmdDbGllbnRSZWN0LnRvcCAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWxwZXJDbGFzcykge1xuICAgICAgICAgIHZhciBfaGVscGVyJGNsYXNzTGlzdDtcblxuICAgICAgICAgIChfaGVscGVyJGNsYXNzTGlzdCA9IHRoaXMuaGVscGVyLmNsYXNzTGlzdCkuYWRkLmFwcGx5KF9oZWxwZXIkY2xhc3NMaXN0LCB0b0NvbnN1bWFibGVBcnJheShoZWxwZXJDbGFzcy5zcGxpdCgnICcpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxpc3RlbmVyTm9kZSA9IGUudG91Y2hlcyA/IG5vZGUgOiB0aGlzLl93aW5kb3c7XG4gICAgICAgIGV2ZW50cy5tb3ZlLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQubGlzdGVuZXJOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBfdGhpczQuaGFuZGxlU29ydE1vdmUsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50cy5lbmQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzNC5saXN0ZW5lck5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIF90aGlzNC5oYW5kbGVTb3J0RW5kLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc29ydGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc29ydGluZ0luZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgdGhpcy4kZW1pdCgnc29ydC1zdGFydCcsIHsgZXZlbnQ6IGUsIG5vZGU6IG5vZGUsIGluZGV4OiBpbmRleCwgY29sbGVjdGlvbjogY29sbGVjdGlvbiB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVNvcnRNb3ZlOiBmdW5jdGlvbiBoYW5kbGVTb3J0TW92ZShlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIG1vYmlsZVxuXG4gICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKGUpO1xuICAgICAgdGhpcy5hbmltYXRlTm9kZXMoKTtcbiAgICAgIHRoaXMuYXV0b3Njcm9sbCgpO1xuXG4gICAgICB0aGlzLiRlbWl0KCdzb3J0LW1vdmUnLCB7IGV2ZW50OiBlIH0pO1xuICAgIH0sXG4gICAgaGFuZGxlU29ydEVuZDogZnVuY3Rpb24gaGFuZGxlU29ydEVuZChlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLm1hbmFnZXIuYWN0aXZlLmNvbGxlY3Rpb247XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzIGlmIHRoZSBub2RlIGlzIHN0aWxsIGluIHRoZSBET01cblxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJOb2RlKSB7XG4gICAgICAgIGV2ZW50cy5tb3ZlLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczUubGlzdGVuZXJOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBfdGhpczUuaGFuZGxlU29ydE1vdmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRzLmVuZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM1Lmxpc3RlbmVyTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgX3RoaXM1LmhhbmRsZVNvcnRFbmQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5tYW5hZ2VyLnJlZnNbY29sbGVjdGlvbl07XG5cbiAgICAgIHZhciBvbkVuZCA9IGZ1bmN0aW9uIG9uRW5kKCkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGhlbHBlciBmcm9tIHRoZSBET01cbiAgICAgICAgX3RoaXM1LmhlbHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF90aGlzNS5oZWxwZXIpO1xuXG4gICAgICAgIGlmIChfdGhpczUuaGlkZVNvcnRhYmxlR2hvc3QgJiYgX3RoaXM1LnNvcnRhYmxlR2hvc3QpIHtcbiAgICAgICAgICBfdGhpczUuc29ydGFibGVHaG9zdC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgX3RoaXM1LnNvcnRhYmxlR2hvc3Quc3R5bGUub3BhY2l0eSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICB2YXIgZWwgPSBub2RlLm5vZGU7XG5cbiAgICAgICAgICAvLyBDbGVhciB0aGUgY2FjaGVkIG9mZnNldFRvcCAvIG9mZnNldExlZnQgdmFsdWVcbiAgICAgICAgICBub2RlLmVkZ2VPZmZzZXQgPSBudWxsO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFuc2Zvcm1zIC8gdHJhbnNpdGlvbnNcbiAgICAgICAgICBlbC5zdHlsZVt2ZW5kb3JQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSAnJztcbiAgICAgICAgICBlbC5zdHlsZVt2ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkR1cmF0aW9uJ10gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3AgYXV0b3Njcm9sbFxuICAgICAgICBjbGVhckludGVydmFsKF90aGlzNS5hdXRvc2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgICBfdGhpczUuYXV0b3Njcm9sbEludGVydmFsID0gbnVsbDtcblxuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgX3RoaXM1Lm1hbmFnZXIuYWN0aXZlID0gbnVsbDtcblxuICAgICAgICBfdGhpczUuc29ydGluZyA9IGZhbHNlO1xuICAgICAgICBfdGhpczUuc29ydGluZ0luZGV4ID0gbnVsbDtcblxuICAgICAgICBfdGhpczUuJGVtaXQoJ3NvcnQtZW5kJywge1xuICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgIG9sZEluZGV4OiBfdGhpczUuaW5kZXgsXG4gICAgICAgICAgbmV3SW5kZXg6IF90aGlzNS5uZXdJbmRleCxcbiAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpczUuJGVtaXQoJ2lucHV0JywgYXJyYXlNb3ZlKF90aGlzNS52YWx1ZSwgX3RoaXM1LmluZGV4LCBfdGhpczUubmV3SW5kZXgpKTtcblxuICAgICAgICBfdGhpczUuX3RvdWNoZWQgPSBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLiRwcm9wcy50cmFuc2l0aW9uRHVyYXRpb24gfHwgdGhpcy4kcHJvcHMuZHJhZ2dlZFNldHRsaW5nRHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uSGVscGVySW50b1BsYWNlKG5vZGVzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gb25FbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbkVuZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbkhlbHBlckludG9QbGFjZTogZnVuY3Rpb24gdHJhbnNpdGlvbkhlbHBlckludG9QbGFjZShub2Rlcykge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiRwcm9wcy5kcmFnZ2VkU2V0dGxpbmdEdXJhdGlvbiA9PT0gMCB8fCBub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGFTY3JvbGwgPSB7XG4gICAgICAgIGxlZnQ6IHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgLSB0aGlzLmluaXRpYWxTY3JvbGwubGVmdCxcbiAgICAgICAgdG9wOiB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgLSB0aGlzLmluaXRpYWxTY3JvbGwudG9wXG4gICAgICB9O1xuICAgICAgdmFyIGluZGV4Tm9kZSA9IG5vZGVzW3RoaXMuaW5kZXhdLm5vZGU7XG4gICAgICB2YXIgbmV3SW5kZXhOb2RlID0gbm9kZXNbdGhpcy5uZXdJbmRleF0ubm9kZTtcblxuICAgICAgdmFyIHRhcmdldFggPSAtZGVsdGFTY3JvbGwubGVmdDtcbiAgICAgIGlmICh0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS54ID4gMCkge1xuICAgICAgICAvLyBEaWZmIGFnYWluc3QgcmlnaHQgZWRnZSB3aGVuIG1vdmluZyB0byB0aGUgcmlnaHRcbiAgICAgICAgdGFyZ2V0WCArPSBuZXdJbmRleE5vZGUub2Zmc2V0TGVmdCArIG5ld0luZGV4Tm9kZS5vZmZzZXRXaWR0aCAtIChpbmRleE5vZGUub2Zmc2V0TGVmdCArIGluZGV4Tm9kZS5vZmZzZXRXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRYICs9IG5ld0luZGV4Tm9kZS5vZmZzZXRMZWZ0IC0gaW5kZXhOb2RlLm9mZnNldExlZnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXRZID0gLWRlbHRhU2Nyb2xsLnRvcDtcbiAgICAgIGlmICh0aGlzLnRyYW5zbGF0ZSAmJiB0aGlzLnRyYW5zbGF0ZS55ID4gMCkge1xuICAgICAgICAvLyBEaWZmIGFnYWluc3QgdGhlIGJvdHRvbSBlZGdlIHdoZW4gbW92aW5nIGRvd25cbiAgICAgICAgdGFyZ2V0WSArPSBuZXdJbmRleE5vZGUub2Zmc2V0VG9wICsgbmV3SW5kZXhOb2RlLm9mZnNldEhlaWdodCAtIChpbmRleE5vZGUub2Zmc2V0VG9wICsgaW5kZXhOb2RlLm9mZnNldEhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRZICs9IG5ld0luZGV4Tm9kZS5vZmZzZXRUb3AgLSBpbmRleE5vZGUub2Zmc2V0VG9wO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLiRwcm9wcy5kcmFnZ2VkU2V0dGxpbmdEdXJhdGlvbiAhPT0gbnVsbCA/IHRoaXMuJHByb3BzLmRyYWdnZWRTZXR0bGluZ0R1cmF0aW9uIDogdGhpcy4kcHJvcHMudHJhbnNpdGlvbkR1cmF0aW9uO1xuXG4gICAgICB0aGlzLmhlbHBlci5zdHlsZVt2ZW5kb3JQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlM2QoJyArIHRhcmdldFggKyAncHgsJyArIHRhcmdldFkgKyAncHgsIDApJztcbiAgICAgIHRoaXMuaGVscGVyLnN0eWxlW3ZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nXSA9IGR1cmF0aW9uICsgJ21zJztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIgdG8gY2xlYW4gdXAgc3R5bGVzIHdoZW4gdGhlIHRyYW5zaXRpb25cbiAgICAgICAgLy8gZmluaXNoZXMuXG4gICAgICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24gY2xlYW51cChldmVudCkge1xuICAgICAgICAgIGlmICghZXZlbnQgfHwgZXZlbnQucHJvcGVydHlOYW1lID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsZWFudXBUaW1lcik7XG4gICAgICAgICAgICBfdGhpczYuaGVscGVyLnN0eWxlW3ZlbmRvclByZWZpeCArICdUcmFuc2Zvcm0nXSA9ICcnO1xuICAgICAgICAgICAgX3RoaXM2LmhlbHBlci5zdHlsZVt2ZW5kb3JQcmVmaXggKyAnVHJhbnNpdGlvbkR1cmF0aW9uJ10gPSAnJztcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEZvcmNlIGNsZWFudXAgaW4gY2FzZSAndHJhbnNpdGlvbmVuZCcgbmV2ZXIgZmlyZXNcbiAgICAgICAgdmFyIGNsZWFudXBUaW1lciA9IHNldFRpbWVvdXQoY2xlYW51cCwgZHVyYXRpb24gKyAxMCk7XG4gICAgICAgIF90aGlzNi5oZWxwZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGNsZWFudXAsIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0RWRnZU9mZnNldDogZnVuY3Rpb24gZ2V0RWRnZU9mZnNldChub2RlKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG4gICAgICAvLyBHZXQgdGhlIGFjdHVhbCBvZmZzZXRUb3AgLyBvZmZzZXRMZWZ0IHZhbHVlLCBubyBtYXR0ZXIgaG93IGRlZXAgdGhlIG5vZGUgaXMgbmVzdGVkXG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICB2YXIgbm9kZU9mZnNldCA9IHtcbiAgICAgICAgICB0b3A6IG9mZnNldC50b3AgKyBub2RlLm9mZnNldFRvcCxcbiAgICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCArIG5vZGUub2Zmc2V0TGVmdFxuICAgICAgICB9O1xuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSB0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldEVkZ2VPZmZzZXQobm9kZS5wYXJlbnROb2RlLCBub2RlT2Zmc2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9kZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0T2Zmc2V0OiBmdW5jdGlvbiBnZXRPZmZzZXQoZSkge1xuICAgICAgdmFyIF9yZWYyID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZSxcbiAgICAgICAgICBwYWdlWCA9IF9yZWYyLnBhZ2VYLFxuICAgICAgICAgIHBhZ2VZID0gX3JlZjIucGFnZVk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBhZ2VYLFxuICAgICAgICB5OiBwYWdlWVxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldExvY2tQaXhlbE9mZnNldHM6IGZ1bmN0aW9uIGdldExvY2tQaXhlbE9mZnNldHMoKSB7XG4gICAgICB2YXIgbG9ja09mZnNldCA9IHRoaXMuJHByb3BzLmxvY2tPZmZzZXQ7XG5cblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMubG9ja09mZnNldCkpIHtcbiAgICAgICAgbG9ja09mZnNldCA9IFtsb2NrT2Zmc2V0LCBsb2NrT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvY2tPZmZzZXQubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9ja09mZnNldCBwcm9wIG9mIFNvcnRhYmxlQ29udGFpbmVyIHNob3VsZCBiZSBhIHNpbmdsZSB2YWx1ZSBvciBhbiBhcnJheSBvZiBleGFjdGx5IHR3byB2YWx1ZXMuIEdpdmVuICcgKyBsb2NrT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIF9sb2NrT2Zmc2V0ID0gbG9ja09mZnNldCxcbiAgICAgICAgICBfbG9ja09mZnNldDIgPSBzbGljZWRUb0FycmF5KF9sb2NrT2Zmc2V0LCAyKSxcbiAgICAgICAgICBtaW5Mb2NrT2Zmc2V0ID0gX2xvY2tPZmZzZXQyWzBdLFxuICAgICAgICAgIG1heExvY2tPZmZzZXQgPSBfbG9ja09mZnNldDJbMV07XG5cbiAgICAgIHJldHVybiBbdGhpcy5nZXRMb2NrUGl4ZWxPZmZzZXQobWluTG9ja09mZnNldCksIHRoaXMuZ2V0TG9ja1BpeGVsT2Zmc2V0KG1heExvY2tPZmZzZXQpXTtcbiAgICB9LFxuICAgIGdldExvY2tQaXhlbE9mZnNldDogZnVuY3Rpb24gZ2V0TG9ja1BpeGVsT2Zmc2V0KGxvY2tPZmZzZXQpIHtcbiAgICAgIHZhciBvZmZzZXRYID0gbG9ja09mZnNldDtcbiAgICAgIHZhciBvZmZzZXRZID0gbG9ja09mZnNldDtcbiAgICAgIHZhciB1bml0ID0gJ3B4JztcblxuICAgICAgaWYgKHR5cGVvZiBsb2NrT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbWF0Y2ggPSAvXlsrLV0/XFxkKig/OlxcLlxcZCopPyhweHwlKSQvLmV4ZWMobG9ja09mZnNldCk7XG5cbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2NrT2Zmc2V0IHZhbHVlIHNob3VsZCBiZSBhIG51bWJlciBvciBhIHN0cmluZyBvZiBhIG51bWJlciBmb2xsb3dlZCBieSBcInB4XCIgb3IgXCIlXCIuIEdpdmVuICcgKyBsb2NrT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldFggPSBvZmZzZXRZID0gcGFyc2VGbG9hdChsb2NrT2Zmc2V0KTtcbiAgICAgICAgdW5pdCA9IG1hdGNoWzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzRmluaXRlKG9mZnNldFgpIHx8ICFpc0Zpbml0ZShvZmZzZXRZKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvY2tPZmZzZXQgdmFsdWUgc2hvdWxkIGJlIGEgZmluaXRlLiBHaXZlbiAnICsgbG9ja09mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bml0ID09PSAnJScpIHtcbiAgICAgICAgb2Zmc2V0WCA9IG9mZnNldFggKiB0aGlzLndpZHRoIC8gMTAwO1xuICAgICAgICBvZmZzZXRZID0gb2Zmc2V0WSAqIHRoaXMuaGVpZ2h0IC8gMTAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBvZmZzZXRYLFxuICAgICAgICB5OiBvZmZzZXRZXG4gICAgICB9O1xuICAgIH0sXG4gICAgdXBkYXRlUG9zaXRpb246IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKGUpIHtcbiAgICAgIHZhciBfJHByb3BzNCA9IHRoaXMuJHByb3BzLFxuICAgICAgICAgIGxvY2tBeGlzID0gXyRwcm9wczQubG9ja0F4aXMsXG4gICAgICAgICAgbG9ja1RvQ29udGFpbmVyRWRnZXMgPSBfJHByb3BzNC5sb2NrVG9Db250YWluZXJFZGdlcztcblxuXG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5nZXRPZmZzZXQoZSk7XG4gICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICB4OiBvZmZzZXQueCAtIHRoaXMuaW5pdGlhbE9mZnNldC54LFxuICAgICAgICB5OiBvZmZzZXQueSAtIHRoaXMuaW5pdGlhbE9mZnNldC55XG4gICAgICB9O1xuICAgICAgLy8gQWRqdXN0IGZvciB3aW5kb3cgc2Nyb2xsXG4gICAgICB0cmFuc2xhdGUueSAtPSB3aW5kb3cucGFnZVlPZmZzZXQgLSB0aGlzLmluaXRpYWxXaW5kb3dTY3JvbGwudG9wO1xuICAgICAgdHJhbnNsYXRlLnggLT0gd2luZG93LnBhZ2VYT2Zmc2V0IC0gdGhpcy5pbml0aWFsV2luZG93U2Nyb2xsLmxlZnQ7XG5cbiAgICAgIHRoaXMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xuXG4gICAgICBpZiAobG9ja1RvQ29udGFpbmVyRWRnZXMpIHtcbiAgICAgICAgdmFyIF9nZXRMb2NrUGl4ZWxPZmZzZXRzID0gdGhpcy5nZXRMb2NrUGl4ZWxPZmZzZXRzKCksXG4gICAgICAgICAgICBfZ2V0TG9ja1BpeGVsT2Zmc2V0czIgPSBzbGljZWRUb0FycmF5KF9nZXRMb2NrUGl4ZWxPZmZzZXRzLCAyKSxcbiAgICAgICAgICAgIG1pbkxvY2tPZmZzZXQgPSBfZ2V0TG9ja1BpeGVsT2Zmc2V0czJbMF0sXG4gICAgICAgICAgICBtYXhMb2NrT2Zmc2V0ID0gX2dldExvY2tQaXhlbE9mZnNldHMyWzFdO1xuXG4gICAgICAgIHZhciBtaW5PZmZzZXQgPSB7XG4gICAgICAgICAgeDogdGhpcy53aWR0aCAvIDIgLSBtaW5Mb2NrT2Zmc2V0LngsXG4gICAgICAgICAgeTogdGhpcy5oZWlnaHQgLyAyIC0gbWluTG9ja09mZnNldC55XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYXhPZmZzZXQgPSB7XG4gICAgICAgICAgeDogdGhpcy53aWR0aCAvIDIgLSBtYXhMb2NrT2Zmc2V0LngsXG4gICAgICAgICAgeTogdGhpcy5oZWlnaHQgLyAyIC0gbWF4TG9ja09mZnNldC55XG4gICAgICAgIH07XG5cbiAgICAgICAgdHJhbnNsYXRlLnggPSBsaW1pdCh0aGlzLm1pblRyYW5zbGF0ZS54ICsgbWluT2Zmc2V0LngsIHRoaXMubWF4VHJhbnNsYXRlLnggLSBtYXhPZmZzZXQueCwgdHJhbnNsYXRlLngpO1xuICAgICAgICB0cmFuc2xhdGUueSA9IGxpbWl0KHRoaXMubWluVHJhbnNsYXRlLnkgKyBtaW5PZmZzZXQueSwgdGhpcy5tYXhUcmFuc2xhdGUueSAtIG1heE9mZnNldC55LCB0cmFuc2xhdGUueSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsb2NrQXhpcyA9PT0gJ3gnKSB7XG4gICAgICAgIHRyYW5zbGF0ZS55ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAobG9ja0F4aXMgPT09ICd5Jykge1xuICAgICAgICB0cmFuc2xhdGUueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaGVscGVyLnN0eWxlW3ZlbmRvclByZWZpeCArICdUcmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGUzZCgnICsgdHJhbnNsYXRlLnggKyAncHgsJyArIHRyYW5zbGF0ZS55ICsgJ3B4LCAwKSc7XG4gICAgfSxcbiAgICBhbmltYXRlTm9kZXM6IGZ1bmN0aW9uIGFuaW1hdGVOb2RlcygpIHtcbiAgICAgIHZhciBfJHByb3BzNSA9IHRoaXMuJHByb3BzLFxuICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IF8kcHJvcHM1LnRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgICAgICBoaWRlU29ydGFibGVHaG9zdCA9IF8kcHJvcHM1LmhpZGVTb3J0YWJsZUdob3N0O1xuXG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm1hbmFnZXIuZ2V0T3JkZXJlZFJlZnMoKTtcbiAgICAgIHZhciBkZWx0YVNjcm9sbCA9IHtcbiAgICAgICAgbGVmdDogdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCAtIHRoaXMuaW5pdGlhbFNjcm9sbC5sZWZ0LFxuICAgICAgICB0b3A6IHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCAtIHRoaXMuaW5pdGlhbFNjcm9sbC50b3BcbiAgICAgIH07XG4gICAgICB2YXIgc29ydGluZ09mZnNldCA9IHtcbiAgICAgICAgbGVmdDogdGhpcy5vZmZzZXRFZGdlLmxlZnQgKyB0aGlzLnRyYW5zbGF0ZS54ICsgZGVsdGFTY3JvbGwubGVmdCxcbiAgICAgICAgdG9wOiB0aGlzLm9mZnNldEVkZ2UudG9wICsgdGhpcy50cmFuc2xhdGUueSArIGRlbHRhU2Nyb2xsLnRvcFxuICAgICAgfTtcbiAgICAgIHZhciBzY3JvbGxEaWZmZXJlbmNlID0ge1xuICAgICAgICB0b3A6IHdpbmRvdy5wYWdlWU9mZnNldCAtIHRoaXMuaW5pdGlhbFdpbmRvd1Njcm9sbC50b3AsXG4gICAgICAgIGxlZnQ6IHdpbmRvdy5wYWdlWE9mZnNldCAtIHRoaXMuaW5pdGlhbFdpbmRvd1Njcm9sbC5sZWZ0XG4gICAgICB9O1xuICAgICAgdGhpcy5uZXdJbmRleCA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBub2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldLm5vZGU7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gbm9kZS5zb3J0YWJsZUluZm8uaW5kZXg7XG4gICAgICAgIHZhciB3aWR0aCA9IG5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBub2RlLm9mZnNldEhlaWdodDtcbiAgICAgICAgdmFyIG9mZnNldCA9IHtcbiAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCA+IHdpZHRoID8gd2lkdGggLyAyIDogdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCA+IGhlaWdodCA/IGhlaWdodCAvIDIgOiB0aGlzLmhlaWdodCAvIDJcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZWRnZU9mZnNldCA9IG5vZGVzW2ldLmVkZ2VPZmZzZXQ7XG5cbiAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBjYWNoZWQgdGhlIG5vZGUncyBvZmZzZXRUb3AgLyBvZmZzZXRMZWZ0IHZhbHVlXG5cbiAgICAgICAgaWYgKCFlZGdlT2Zmc2V0KSB7XG4gICAgICAgICAgbm9kZXNbaV0uZWRnZU9mZnNldCA9IGVkZ2VPZmZzZXQgPSB0aGlzLmdldEVkZ2VPZmZzZXQobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIG5leHQgYW5kIHByZXZpb3VzIG5vZGVcbiAgICAgICAgdmFyIG5leHROb2RlID0gaSA8IG5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZXNbaSArIDFdO1xuICAgICAgICB2YXIgcHJldk5vZGUgPSBpID4gMCAmJiBub2Rlc1tpIC0gMV07XG5cbiAgICAgICAgLy8gQWxzbyBjYWNoZSB0aGUgbmV4dCBub2RlJ3MgZWRnZSBvZmZzZXQgaWYgbmVlZGVkLlxuICAgICAgICAvLyBXZSBuZWVkIHRoaXMgZm9yIGNhbGN1bGF0aW5nIHRoZSBhbmltYXRpb24gaW4gYSBncmlkIHNldHVwXG4gICAgICAgIGlmIChuZXh0Tm9kZSAmJiAhbmV4dE5vZGUuZWRnZU9mZnNldCkge1xuICAgICAgICAgIG5leHROb2RlLmVkZ2VPZmZzZXQgPSB0aGlzLmdldEVkZ2VPZmZzZXQobmV4dE5vZGUubm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyB0aGUgb25lIHdlJ3JlIGN1cnJlbnRseSBhbmltYXRpbmcsIHNraXAgaXRcbiAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLmluZGV4KSB7XG4gICAgICAgICAgaWYgKGhpZGVTb3J0YWJsZUdob3N0KSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiBXaXRoIHdpbmRvd2luZyBsaWJyYXJpZXMgc3VjaCBhcyBgcmVhY3QtdmlydHVhbGl6ZWRgLCB0aGUgc29ydGFibGVHaG9zdFxuICAgICAgICAgICAgKiBub2RlIG1heSBjaGFuZ2Ugd2hpbGUgc2Nyb2xsaW5nIGRvd24gYW5kIHRoZW4gYmFjayB1cCAob3IgdmljZS12ZXJzYSksXG4gICAgICAgICAgICAqIHNvIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSByZWZlcmVuY2UgdG8gdGhlIG5ldyBub2RlIGp1c3QgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnNvcnRhYmxlR2hvc3QgPSBub2RlO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgICAgICBub2RlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICBub2RlLnN0eWxlW3ZlbmRvclByZWZpeCArICdUcmFuc2l0aW9uRHVyYXRpb24nXSA9IHRyYW5zaXRpb25EdXJhdGlvbiArICdtcyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYXhpcy54KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2F4aXMueSkge1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRpb25zIGZvciBhIGdyaWQgc2V0dXBcbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRoaXMuaW5kZXggJiYgKHNvcnRpbmdPZmZzZXQubGVmdCArIHNjcm9sbERpZmZlcmVuY2UubGVmdCAtIG9mZnNldC53aWR0aCA8PSBlZGdlT2Zmc2V0LmxlZnQgJiYgc29ydGluZ09mZnNldC50b3AgKyBzY3JvbGxEaWZmZXJlbmNlLnRvcCA8PSBlZGdlT2Zmc2V0LnRvcCArIG9mZnNldC5oZWlnaHQgfHwgc29ydGluZ09mZnNldC50b3AgKyBzY3JvbGxEaWZmZXJlbmNlLnRvcCArIG9mZnNldC5oZWlnaHQgPD0gZWRnZU9mZnNldC50b3ApKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgdG8gdGhlIGxlZnQgb24gdGhlIHNhbWUgcm93LCBvciBhYm92ZSB0aGUgbm9kZSB0aGF0J3MgYmVpbmcgZHJhZ2dlZFxuICAgICAgICAgICAgICAvLyB0aGVuIG1vdmUgaXQgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICAgIHRyYW5zbGF0ZS54ID0gdGhpcy53aWR0aCArIHRoaXMubWFyZ2luT2Zmc2V0Lng7XG4gICAgICAgICAgICAgIGlmIChlZGdlT2Zmc2V0LmxlZnQgKyB0cmFuc2xhdGUueCA+IHRoaXMuY29udGFpbmVyQm91bmRpbmdSZWN0LndpZHRoIC0gb2Zmc2V0LndpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgbW92ZXMgcGFzc2VkIHRoZSByaWdodCBib3VuZHMsIHRoZW4gYW5pbWF0ZSBpdCB0byB0aGUgZmlyc3QgcG9zaXRpb24gb2YgdGhlIG5leHQgcm93LlxuICAgICAgICAgICAgICAgIC8vIFdlIGp1c3QgdXNlIHRoZSBvZmZzZXQgb2YgdGhlIG5leHQgbm9kZSB0byBjYWxjdWxhdGUgd2hlcmUgdG8gbW92ZSwgYmVjYXVzZSB0aGF0IG5vZGUncyBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIGlzIGV4YWN0bHkgd2hlcmUgd2Ugd2FudCB0byBnb1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZS54ID0gbmV4dE5vZGUuZWRnZU9mZnNldC5sZWZ0IC0gZWRnZU9mZnNldC5sZWZ0O1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZS55ID0gbmV4dE5vZGUuZWRnZU9mZnNldC50b3AgLSBlZGdlT2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5uZXdJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IHRoaXMuaW5kZXggJiYgKHNvcnRpbmdPZmZzZXQubGVmdCArIHNjcm9sbERpZmZlcmVuY2UubGVmdCArIG9mZnNldC53aWR0aCA+PSBlZGdlT2Zmc2V0LmxlZnQgJiYgc29ydGluZ09mZnNldC50b3AgKyBzY3JvbGxEaWZmZXJlbmNlLnRvcCArIG9mZnNldC5oZWlnaHQgPj0gZWRnZU9mZnNldC50b3AgfHwgc29ydGluZ09mZnNldC50b3AgKyBzY3JvbGxEaWZmZXJlbmNlLnRvcCArIG9mZnNldC5oZWlnaHQgPj0gZWRnZU9mZnNldC50b3AgKyBoZWlnaHQpKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IG5vZGUgaXMgdG8gdGhlIHJpZ2h0IG9uIHRoZSBzYW1lIHJvdywgb3IgYmVsb3cgdGhlIG5vZGUgdGhhdCdzIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgICAgICAgLy8gdGhlbiBtb3ZlIGl0IHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICAgIHRyYW5zbGF0ZS54ID0gLSh0aGlzLndpZHRoICsgdGhpcy5tYXJnaW5PZmZzZXQueCk7XG4gICAgICAgICAgICAgIGlmIChlZGdlT2Zmc2V0LmxlZnQgKyB0cmFuc2xhdGUueCA8IHRoaXMuY29udGFpbmVyQm91bmRpbmdSZWN0LmxlZnQgKyBvZmZzZXQud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBtb3ZlcyBwYXNzZWQgdGhlIGxlZnQgYm91bmRzLCB0aGVuIGFuaW1hdGUgaXQgdG8gdGhlIGxhc3QgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIHJvdy5cbiAgICAgICAgICAgICAgICAvLyBXZSBqdXN0IHVzZSB0aGUgb2Zmc2V0IG9mIHRoZSBwcmV2aW91cyBub2RlIHRvIGNhbGN1bGF0ZSB3aGVyZSB0byBtb3ZlLCBiZWNhdXNlIHRoYXQgbm9kZSdzIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gaXMgZXhhY3RseSB3aGVyZSB3ZSB3YW50IHRvIGdvXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlLnggPSBwcmV2Tm9kZS5lZGdlT2Zmc2V0LmxlZnQgLSBlZGdlT2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlLnkgPSBwcmV2Tm9kZS5lZGdlT2Zmc2V0LnRvcCAtIGVkZ2VPZmZzZXQudG9wO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMubmV3SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gdGhpcy5pbmRleCAmJiBzb3J0aW5nT2Zmc2V0LmxlZnQgKyBzY3JvbGxEaWZmZXJlbmNlLmxlZnQgKyBvZmZzZXQud2lkdGggPj0gZWRnZU9mZnNldC5sZWZ0KSB7XG4gICAgICAgICAgICAgIHRyYW5zbGF0ZS54ID0gLSh0aGlzLndpZHRoICsgdGhpcy5tYXJnaW5PZmZzZXQueCk7XG4gICAgICAgICAgICAgIHRoaXMubmV3SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCB0aGlzLmluZGV4ICYmIHNvcnRpbmdPZmZzZXQubGVmdCArIHNjcm9sbERpZmZlcmVuY2UubGVmdCA8PSBlZGdlT2Zmc2V0LmxlZnQgKyBvZmZzZXQud2lkdGgpIHtcbiAgICAgICAgICAgICAgdHJhbnNsYXRlLnggPSB0aGlzLndpZHRoICsgdGhpcy5tYXJnaW5PZmZzZXQueDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubmV3SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9heGlzLnkpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPiB0aGlzLmluZGV4ICYmIHNvcnRpbmdPZmZzZXQudG9wICsgc2Nyb2xsRGlmZmVyZW5jZS50b3AgKyBvZmZzZXQuaGVpZ2h0ID49IGVkZ2VPZmZzZXQudG9wKSB7XG4gICAgICAgICAgICB0cmFuc2xhdGUueSA9IC0odGhpcy5oZWlnaHQgKyB0aGlzLm1hcmdpbk9mZnNldC55KTtcbiAgICAgICAgICAgIHRoaXMubmV3SW5kZXggPSBpbmRleDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgdGhpcy5pbmRleCAmJiBzb3J0aW5nT2Zmc2V0LnRvcCArIHNjcm9sbERpZmZlcmVuY2UudG9wIDw9IGVkZ2VPZmZzZXQudG9wICsgb2Zmc2V0LmhlaWdodCkge1xuICAgICAgICAgICAgdHJhbnNsYXRlLnkgPSB0aGlzLmhlaWdodCArIHRoaXMubWFyZ2luT2Zmc2V0Lnk7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXdJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMubmV3SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5zdHlsZVt2ZW5kb3JQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlM2QoJyArIHRyYW5zbGF0ZS54ICsgJ3B4LCcgKyB0cmFuc2xhdGUueSArICdweCwwKSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5ld0luZGV4ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5uZXdJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICB9XG4gICAgfSxcbiAgICBhdXRvc2Nyb2xsOiBmdW5jdGlvbiBhdXRvc2Nyb2xsKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciB0cmFuc2xhdGUgPSB0aGlzLnRyYW5zbGF0ZTtcbiAgICAgIHZhciBkaXJlY3Rpb24gPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICB2YXIgc3BlZWQgPSB7XG4gICAgICAgIHg6IDEsXG4gICAgICAgIHk6IDFcbiAgICAgIH07XG4gICAgICB2YXIgYWNjZWxlcmF0aW9uID0ge1xuICAgICAgICB4OiAxMCxcbiAgICAgICAgeTogMTBcbiAgICAgIH07XG5cbiAgICAgIGlmICh0cmFuc2xhdGUueSA+PSB0aGlzLm1heFRyYW5zbGF0ZS55IC0gdGhpcy5oZWlnaHQgLyAyKSB7XG4gICAgICAgIGRpcmVjdGlvbi55ID0gMTsgLy8gU2Nyb2xsIERvd25cbiAgICAgICAgc3BlZWQueSA9IGFjY2VsZXJhdGlvbi55ICogTWF0aC5hYnMoKHRoaXMubWF4VHJhbnNsYXRlLnkgLSB0aGlzLmhlaWdodCAvIDIgLSB0cmFuc2xhdGUueSkgLyB0aGlzLmhlaWdodCk7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZS54ID49IHRoaXMubWF4VHJhbnNsYXRlLnggLSB0aGlzLndpZHRoIC8gMikge1xuICAgICAgICBkaXJlY3Rpb24ueCA9IDE7IC8vIFNjcm9sbCBSaWdodFxuICAgICAgICBzcGVlZC54ID0gYWNjZWxlcmF0aW9uLnggKiBNYXRoLmFicygodGhpcy5tYXhUcmFuc2xhdGUueCAtIHRoaXMud2lkdGggLyAyIC0gdHJhbnNsYXRlLngpIC8gdGhpcy53aWR0aCk7XG4gICAgICB9IGVsc2UgaWYgKHRyYW5zbGF0ZS55IDw9IHRoaXMubWluVHJhbnNsYXRlLnkgKyB0aGlzLmhlaWdodCAvIDIpIHtcbiAgICAgICAgZGlyZWN0aW9uLnkgPSAtMTsgLy8gU2Nyb2xsIFVwXG4gICAgICAgIHNwZWVkLnkgPSBhY2NlbGVyYXRpb24ueSAqIE1hdGguYWJzKCh0cmFuc2xhdGUueSAtIHRoaXMuaGVpZ2h0IC8gMiAtIHRoaXMubWluVHJhbnNsYXRlLnkpIC8gdGhpcy5oZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmICh0cmFuc2xhdGUueCA8PSB0aGlzLm1pblRyYW5zbGF0ZS54ICsgdGhpcy53aWR0aCAvIDIpIHtcbiAgICAgICAgZGlyZWN0aW9uLnggPSAtMTsgLy8gU2Nyb2xsIExlZnRcbiAgICAgICAgc3BlZWQueCA9IGFjY2VsZXJhdGlvbi54ICogTWF0aC5hYnMoKHRyYW5zbGF0ZS54IC0gdGhpcy53aWR0aCAvIDIgLSB0aGlzLm1pblRyYW5zbGF0ZS54KSAvIHRoaXMud2lkdGgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hdXRvc2Nyb2xsSW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9zY3JvbGxJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuYXV0b3Njcm9sbEludGVydmFsID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0F1dG9TY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcmVjdGlvbi54ICE9PSAwIHx8IGRpcmVjdGlvbi55ICE9PSAwKSB7XG4gICAgICAgIHRoaXMuYXV0b3Njcm9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNy5pc0F1dG9TY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSB7XG4gICAgICAgICAgICBsZWZ0OiAxICogc3BlZWQueCAqIGRpcmVjdGlvbi54LFxuICAgICAgICAgICAgdG9wOiAxICogc3BlZWQueSAqIGRpcmVjdGlvbi55XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdGhpczcuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCArPSBvZmZzZXQudG9wO1xuICAgICAgICAgIF90aGlzNy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArPSBvZmZzZXQubGVmdDtcbiAgICAgICAgICBfdGhpczcudHJhbnNsYXRlLnggKz0gb2Zmc2V0LmxlZnQ7XG4gICAgICAgICAgX3RoaXM3LnRyYW5zbGF0ZS55ICs9IG9mZnNldC50b3A7XG4gICAgICAgICAgX3RoaXM3LmFuaW1hdGVOb2RlcygpO1xuICAgICAgICB9LCA1KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIEV4cG9ydCBTb3J0YWJsZSBFbGVtZW50IEhhbmRsZSBEaXJlY3RpdmVcbnZhciBIYW5kbGVEaXJlY3RpdmUgPSB7XG4gIGJpbmQ6IGZ1bmN0aW9uIGJpbmQoZWwpIHtcbiAgICBlbC5zb3J0YWJsZUhhbmRsZSA9IHRydWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBtaXhpbikge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgbWl4aW5zOiBbbWl4aW5dLFxuICAgIHByb3BzOiB7XG4gICAgICB0YWc6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnZGl2J1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgICAgcmV0dXJuIGgodGhpcy50YWcsIHRoaXMuJHNsb3RzLmRlZmF1bHQpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFNsaWNrTGlzdCA9IGNyZWF0ZSgnc2xpY2stbGlzdCcsIENvbnRhaW5lck1peGluKTtcbnZhciBTbGlja0l0ZW0gPSBjcmVhdGUoJ3NsaWNrLWl0ZW0nLCBFbGVtZW50TWl4aW4pO1xuXG5leHBvcnRzLkVsZW1lbnRNaXhpbiA9IEVsZW1lbnRNaXhpbjtcbmV4cG9ydHMuQ29udGFpbmVyTWl4aW4gPSBDb250YWluZXJNaXhpbjtcbmV4cG9ydHMuSGFuZGxlRGlyZWN0aXZlID0gSGFuZGxlRGlyZWN0aXZlO1xuZXhwb3J0cy5TbGlja0xpc3QgPSBTbGlja0xpc3Q7XG5leHBvcnRzLlNsaWNrSXRlbSA9IFNsaWNrSXRlbTtcbmV4cG9ydHMuYXJyYXlNb3ZlID0gYXJyYXlNb3ZlO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-slicksort/dist/vue-slicksort.umd.js\n");

/***/ })

}]);